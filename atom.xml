<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>潇湘夜雨</title>
  
  <subtitle>知其然，知其所以然</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2019-09-25T10:58:51.387Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>潇湘夜雨</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>装饰器</title>
    <link href="http://yoursite.com/2019/09/25/%E8%A3%85%E9%A5%B0%E5%99%A8/"/>
    <id>http://yoursite.com/2019/09/25/装饰器/</id>
    <published>2019-09-25T10:57:36.000Z</published>
    <updated>2019-09-25T10:58:51.387Z</updated>
    
    <content type="html"><![CDATA[<p><strong>装饰器，就是通过装饰器函数，来修改原函数的一些功能，使得原函数不需修改</strong></p><h4 id="1-函数核心"><a href="#1-函数核心" class="headerlink" title="1. 函数核心"></a>1. 函数核心</h4><p>在python中，函数是一等公民(first-class citizen),  函数也是对象。<br><a id="more"></a><br>1) 把函数赋予变量。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">func</span><span class="params">(vara)</span>:</span></span><br><span class="line">    print(<span class="string">'Got a message: &#123;&#125;'</span>.format(vara))</span><br><span class="line">    </span><br><span class="line">message = func</span><br><span class="line">message(<span class="string">'hello'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出</span></span><br><span class="line">Got a message: hello</span><br></pre></td></tr></table></figure><p>2) 把函数作为参数，传入另一个函数</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_message</span><span class="params">(vara)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> <span class="string">'Got a message: '</span> + vara</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">root_call</span><span class="params">(func, varb)</span>:</span></span><br><span class="line">    print(func(varb))</span><br><span class="line">    </span><br><span class="line"><span class="comment"># func 指向 get_message, varb 指向 'hello'</span></span><br><span class="line">root_call(get_message, <span class="string">'hello'</span>)  </span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出</span></span><br><span class="line">Got a message: hello</span><br></pre></td></tr></table></figure><p>3)  函数里定义函数（函数的嵌套）<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">func</span><span class="params">(vara)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get_message</span><span class="params">(vara)</span>:</span></span><br><span class="line">        print(<span class="string">'Got a message: &#123;&#125;'</span>.format(vara))</span><br><span class="line">    <span class="keyword">return</span> get_message(vara)</span><br><span class="line"></span><br><span class="line">func(<span class="string">'hello'</span>)</span><br><span class="line"><span class="comment"># 变量vara 指向了 参数'hello'  func 函数返回了 get_message(vara)的执行</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出</span></span><br><span class="line">Got a message: hello</span><br></pre></td></tr></table></figure></p><p>4) 函数的返回值也可以是函数对象（闭包）<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">funca</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get_message</span><span class="params">(vara)</span>:</span></span><br><span class="line">        print(<span class="string">'Got a message: &#123;&#125;'</span>.format(vara))</span><br><span class="line">    <span class="keyword">return</span> get_message</span><br><span class="line"></span><br><span class="line">message = funca()  <span class="comment"># message 变量 指向了 funca() 执行体（返回值get_message）,</span></span><br><span class="line">message(<span class="string">'hello'</span>)  <span class="comment"># vara 指向了 message 带进来的参数.</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出</span></span><br><span class="line">Got a message: hello</span><br></pre></td></tr></table></figure></p><h4 id="2-简单的装饰器"><a href="#2-简单的装饰器" class="headerlink" title="2. 简单的装饰器"></a>2. 简单的装饰器</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 对原函数输出添加问候</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">decorator</span><span class="params">(func)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">wrapper</span><span class="params">()</span>:</span></span><br><span class="line">        print(<span class="string">'hello'</span>)</span><br><span class="line">        func()</span><br><span class="line">    <span class="keyword">return</span> wrapper</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">greet</span><span class="params">()</span>:</span></span><br><span class="line">    print(<span class="string">'libai'</span>)</span><br><span class="line"></span><br><span class="line">greet = decorator(greet)  <span class="comment"># func 指向函数 greet,greet 重新指向函数 wrapper</span></span><br><span class="line">greet() <span class="comment"># greet() 就等价于 wrapper() 有于 func 指向了原来的greet 所以func() 输出libai</span></span><br><span class="line"></span><br><span class="line">print(<span class="string">'='</span>*<span class="number">30</span>)</span><br><span class="line"><span class="comment"># 装饰器的常用写法</span></span><br><span class="line"><span class="meta">@decorator # 使用语法糖的格式对函数添加功能</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">name</span><span class="params">()</span>:</span></span><br><span class="line">    print(<span class="string">'杜甫'</span>)</span><br><span class="line"></span><br><span class="line">name()</span><br><span class="line"><span class="comment"># 输出</span></span><br><span class="line">hello</span><br><span class="line">libai</span><br><span class="line">==============================</span><br><span class="line">hello</span><br><span class="line">杜甫</span><br></pre></td></tr></table></figure><h5 id="2-1-带参数的装饰器"><a href="#2-1-带参数的装饰器" class="headerlink" title="2.1 带参数的装饰器"></a>2.1 带参数的装饰器</h5><p>​        如果原函数greet () 中有参数需要传递给装饰器，而另外一个函数也需要使用decorator 装饰器，但是新的函数有两个参数，该如何？</p><p>​        通常情况下，我们会把*args和**kwargs，作为装饰器内部函数wrapper() 的参数。</p><p>​        *args 和 **kwargs 表示接受任意数量和类型的参数</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">decorator</span><span class="params">(func)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">wrapper</span><span class="params">(*args, **kwargs)</span>:</span></span><br><span class="line">        print(<span class="string">'hello'</span>)</span><br><span class="line">        func(*args, **kwargs)</span><br><span class="line">    <span class="keyword">return</span> wrapper</span><br></pre></td></tr></table></figure><h5 id="2-2-带有自定义参数的装饰器"><a href="#2-2-带有自定义参数的装饰器" class="headerlink" title="2.2 带有自定义参数的装饰器"></a>2.2 带有自定义参数的装饰器</h5><p>装饰器有更大程度的灵活性。装饰器除了可以接受原函数任意类型和数量的参数，还可以接受自己定义的参数</p><p>比如定义一个参数，表示装饰器内部函数被执行的次数，如下：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">repeat</span><span class="params">(num)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">decorator</span><span class="params">(func)</span>:</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">wrapper</span><span class="params">(*args, **kwargs)</span>:</span></span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> range(num):</span><br><span class="line">                print(<span class="string">'hello'</span>)</span><br><span class="line">                func(*args, **kwargs)</span><br><span class="line">        <span class="keyword">return</span> wrapper</span><br><span class="line">    <span class="keyword">return</span> my_decorator</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@repeat(3)</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">greet</span><span class="params">(message)</span>:</span></span><br><span class="line">    print(message)</span><br><span class="line"></span><br><span class="line">greet(<span class="string">'libai'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出：</span></span><br><span class="line">hello</span><br><span class="line">libai</span><br><span class="line">hello</span><br><span class="line">libai</span><br><span class="line">hello</span><br><span class="line">libai</span><br></pre></td></tr></table></figure></p><h4 id="3-装饰器的用法实例"><a href="#3-装饰器的用法实例" class="headerlink" title="3. 装饰器的用法实例"></a>3. 装饰器的用法实例</h4><h5 id="3-1-身份认证"><a href="#3-1-身份认证" class="headerlink" title="3.1 身份认证"></a>3.1 身份认证</h5><p>你登录微信，需要输入用户名密码，然后点击确认，这样，服务器端便会查询你的用户名是否存在，是否和密码匹配等等。如果认证通过，你就可以顺利登录；如果不通过，抛出异常显示登陆失败。如下：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> functools</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">authenticate</span><span class="params">(func)</span>:</span></span><br><span class="line"><span class="meta">    @functools.wraps(func)</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">wrapper</span><span class="params">(*args, **kwargs)</span>:</span></span><br><span class="line">        request = args[<span class="number">0</span>]</span><br><span class="line">        <span class="keyword">if</span> check_user_logged_in(request): <span class="comment"># 如果用户处于登录状态</span></span><br><span class="line">            <span class="keyword">return</span> func(*args, **kwargs) <span class="comment"># 执行函数 post_comment() </span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">raise</span> Exception(<span class="string">'Authentication failed'</span>)</span><br><span class="line">    <span class="keyword">return</span> wrapper</span><br><span class="line">    </span><br><span class="line"><span class="meta">@authenticate</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">post_comment</span><span class="params">(request, ...)</span></span></span><br><span class="line"><span class="function">    ...</span></span><br></pre></td></tr></table></figure></p><h5 id="3-2-日志记录"><a href="#3-2-日志记录" class="headerlink" title="3.2 日志记录"></a>3.2 日志记录</h5><p>如果你怀疑某些函数的耗时过长，导致整个系统的延迟增加，所以想在线上测试某些函数的执行时间，那么装饰器就是一种很常用的手段：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">import</span> functools</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">log_execution_time</span><span class="params">(func)</span>:</span></span><br><span class="line"><span class="meta">    @functools.wraps(func)</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">wrapper</span><span class="params">(*args, **kwargs)</span>:</span></span><br><span class="line">        start = time.perf_counter()</span><br><span class="line">        res = func(*args, **kwargs)</span><br><span class="line">        end = time.perf_counter()</span><br><span class="line">        print(<span class="string">'&#123;&#125; took &#123;&#125; ms'</span>.format(func.__name__, (end - start) * <span class="number">1000</span>))</span><br><span class="line">        <span class="keyword">return</span> res</span><br><span class="line">    <span class="keyword">return</span> wrapper</span><br><span class="line">    </span><br><span class="line"><span class="meta">@log_execution_time</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">calculate_similarity</span><span class="params">(items)</span>:</span></span><br><span class="line">    ...</span><br></pre></td></tr></table></figure></p><h5 id="3-3-输入合理性检查"><a href="#3-3-输入合理性检查" class="headerlink" title="3.3 输入合理性检查"></a>3.3 输入合理性检查</h5><p>对一些文件进行合理性检查，避免因为文件格式不正确造成巨大开销<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> functools</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">validation_check</span><span class="params">(input)</span>:</span></span><br><span class="line"><span class="meta">    @functools.wraps(func)</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">wrapper</span><span class="params">(*args, **kwargs)</span>:</span> </span><br><span class="line">        ... <span class="comment"># 检查输入是否合法</span></span><br><span class="line">    </span><br><span class="line"><span class="meta">@validation_check</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">neural_network_training</span><span class="params">(param1, param2, ...)</span>:</span></span><br><span class="line">    ...</span><br></pre></td></tr></table></figure></p><h5 id="3-4-缓存"><a href="#3-4-缓存" class="headerlink" title="3.4 缓存"></a>3.4 缓存</h5><p>缓存装饰器的用法<br>LRU cache, 在 python 中 的表现形式是@lru_cache, @lru_cache 会缓存进程中的函数参数和结果，当缓存满了以后，会删除least recenly used 的数据。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@lru_cache</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">check</span><span class="params">(param1, param2, ...)</span> # 检查用户设备类型，版本号等等</span></span><br><span class="line"><span class="function">    ...</span></span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt;装饰器，就是通过装饰器函数，来修改原函数的一些功能，使得原函数不需修改&lt;/strong&gt;&lt;/p&gt;
&lt;h4 id=&quot;1-函数核心&quot;&gt;&lt;a href=&quot;#1-函数核心&quot; class=&quot;headerlink&quot; title=&quot;1. 函数核心&quot;&gt;&lt;/a&gt;1. 函数核心&lt;/h4&gt;&lt;p&gt;在python中，函数是一等公民(first-class citizen),  函数也是对象。&lt;br&gt;
    
    </summary>
    
      <category term="python" scheme="http://yoursite.com/categories/python/"/>
    
    
      <category term="python" scheme="http://yoursite.com/tags/python/"/>
    
  </entry>
  
  <entry>
    <title>B-树和B+树</title>
    <link href="http://yoursite.com/2019/09/21/B-%E6%A0%91%E5%92%8CB+%E6%A0%91/"/>
    <id>http://yoursite.com/2019/09/21/B-树和B+树/</id>
    <published>2019-09-21T14:16:23.000Z</published>
    <updated>2019-09-25T10:56:34.123Z</updated>
    
    <content type="html"><![CDATA[<h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><p>B树（B-tree）是一种树状数据结构，它能够存储数据、对其进行排序并允许以O(log n)的时间复杂度运行进行查找、顺序读取、插入和删除的数据结构。<a id="more"></a></p><p>B树，概括来说是一个节点可以拥有多于2个子节点的二叉查找树。与自平衡二叉查找树不同，B-树为系统最优化<strong>大块数据的读和写操作</strong>。</p><p>B-tree算法减少定位记录时所经历的中间过程，从而加快存取速度。普遍运用在<strong>数据库</strong>和<strong>文件系统</strong>。”</p><p><strong>B+</strong>树是对B树的一种变形树。区别在于，<strong>B+</strong>树的非叶子结点只包含导航信息，不包含实际的值，所有的叶子结点和相连的节点使用链表相连，便于区间查找和遍历。</p><p><u>B树和B+广泛应用于文件存储系统以及数据库系统中。</u>如：</p><ul><li>Windows：HPFS文件系统</li><li>Mac：HFS，HFS+文件系统</li><li>Linux：ResiserFS，XFS，Ext3FS，JFS文件系统</li><li>数据库：ORACLE，MYSQL，SQLSERVER等中</li></ul><h3 id="B-树"><a href="#B-树" class="headerlink" title="B- 树"></a>B- 树</h3><h4 id="定义："><a href="#定义：" class="headerlink" title="定义："></a>定义：</h4><blockquote><p>B树也称B-树,它是一颗多路平衡查找树。</p><p>我们描述一颗B树时需要指定它的阶数，阶数表示了一个结点最多有多少个孩子结点，一般用字母m表示阶数。当m取2时，就是我们常见的二叉搜索树。</p></blockquote><h5 id="M-阶B-树定义"><a href="#M-阶B-树定义" class="headerlink" title="M 阶B 树定义"></a>M 阶B 树定义</h5><ol><li>非叶子节点最多只有 M 个叶子节点</li><li><p>根节点的子节点数 为 [2，M]</p></li><li><p>非根节点的非叶子节点的叶子节点树为[M/2,M]</p></li><li><p>每个节点存放 [  [M/2  -  1],  [M-1] ] 个关键字（向上取整），<em>（根节点最少可以只有一个关键字）</em></p></li><li><p>关键字都按照从小到大的顺序排列</p></li><li>非叶子节点的关键字个数 = 指向子节点的指针个数-1</li><li>所有叶子节点位于同一层 </li></ol><h4 id="B-树的插入"><a href="#B-树的插入" class="headerlink" title="B 树的插入"></a>B 树的插入</h4><ol><li>新插入的节点总是出现在叶子节点。</li><li>根据插入的key值找到叶子节点并插入。</li><li>判断当前节点 key 的个数 是否小于等于 M-1 若满足 则结束 ，不满足进行下一步。</li><li>以节点中间key 为中心分裂为两部分，然后将这个中间的key 插入到父节点当中 ，左子树指向分裂的左半部分 右子树指向分裂后的右半部分，然后将当前结点指向父结点。</li></ol><h4 id="B-树的删除"><a href="#B-树的删除" class="headerlink" title="B 树的删除"></a>B 树的删除</h4><ol><li>删除节点在叶子节点上，且删除后叶子节点满足B树的要求，则删除结束。</li><li><p>删除节点在非叶子节点上，就使用后继key(当前节点的下一个key) 覆盖要删除的key , 然后删除所在子支中的后继key。删除后满足b树要求，结束，否则执行下一步。</p></li><li><p>删除节点key个数 小于[M/2-1] , 则父节点中的key 下移到该节点，兄弟节点中的一个key 上移，删除操作结束。</p></li><li><p>否则，将父节点中的key 下移与当前节点及他的兄弟节点中的key合并，形成一个新的节点。当前节点的指针指向父节点。</p></li></ol><h3 id="B-树-1"><a href="#B-树-1" class="headerlink" title="B+ 树"></a>B+ 树</h3><h4 id="定义：-1"><a href="#定义：-1" class="headerlink" title="定义："></a>定义：</h4><p>与B 树区别在于：</p><p>非叶子节点的子树指针和关键字的个数相同；</p><h4 id="B-树的插入-1"><a href="#B-树的插入-1" class="headerlink" title="B+ 树的插入"></a>B+ 树的插入</h4><ol><li>若为空树， 创建一个叶子节点，插入记录，本次插入操作结束</li><li>针对叶子节点，根据key值找到叶子节点，向这个叶子节点插入记录。若当前key个数小于等于 M-1 ，则插入结束。否则将这个叶子节点分裂成左右两个叶子节点，左叶子节点包含前M/2 个记录，右节点包含剩下的记录，将第  M/(2+1)   个记录的 key 进位到父结点中（父节点一定是索引类型节点），进位到父节点的key左孩子指针指向左结点，右孩子指针指向右结点，将当前结点的指针指向父节点。</li><li>针对索引类型节点：若当前节点的key 个数 ≤ (M-1) 则插入结束。否则，将这个索引类型结点分裂成两个索引结点，左索引结点包含前 (m-1)/2 个key，右结点包含 m-(m-1)/2 个key，将第m/2个key进位到父结点中，进位到父结点的key左孩子指向左结点, 进位到父结点的key右孩子指向右结点。将当前结点的指针指向父结点，然后重复第3步</li></ol><h4 id="B-树的删除-1"><a href="#B-树的删除-1" class="headerlink" title="B+ 树的删除"></a>B+ 树的删除</h4><p>  如果叶子结点中没有相应的key，则删除失败。否则执行下面的步骤</p><ol><li>删除叶子结点中对应的key。删除后若结点的key的个数大于等于Math.ceil(m-1)/2 – 1，删除操作结束,否则执行第2步。</li><li>若兄弟结点key有富余（大于Math.ceil(m-1)/2 – 1），向兄弟结点借一个记录，同时用借到的key替换父结（指当前结点和兄弟结点共同的父结点）点中的key，删除结束。否则执行第3步。</li><li>若兄弟结点中没有富余的key,则当前结点和兄弟结点合并成一个新的叶子结点，并删除父结点中的key（父结点中的这个key两边的孩子指针就变成了一个指针，正好指向这个新的叶子结点），将当前结点指向父结点（必为索引结点），执行第4步（第4步以后的操作和B树就完全一样了，主要是为了更新索引结点）。</li><li>若索引结点的key的个数大于等于Math.ceil(m-1)/2 – 1，则删除操作结束。否则执行第5步</li><li>若兄弟结点有富余，父结点key下移，兄弟结点key上移，删除结束。否则执行第6步</li><li>当前结点和兄弟结点及父结点下移key合并成一个新的结点。将当前结点指向父结点，重复第4步。</li><li>注意，通过B+树的删除操作后，索引结点中存在的key，不一定在叶子结点中存在对应的记录。</li></ol><p><a href="https://www.cnblogs.com/nullzx/p/8729425.html" target="_blank" rel="noopener">参考链接</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;简介&quot;&gt;&lt;a href=&quot;#简介&quot; class=&quot;headerlink&quot; title=&quot;简介&quot;&gt;&lt;/a&gt;简介&lt;/h3&gt;&lt;p&gt;B树（B-tree）是一种树状数据结构，它能够存储数据、对其进行排序并允许以O(log n)的时间复杂度运行进行查找、顺序读取、插入和删除的数据结构。
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>python解析式</title>
    <link href="http://yoursite.com/2019/04/11/python%E8%A7%A3%E6%9E%90%E5%BC%8F/"/>
    <id>http://yoursite.com/2019/04/11/python解析式/</id>
    <published>2019-04-11T09:21:00.000Z</published>
    <updated>2019-04-21T12:39:06.266Z</updated>
    
    <content type="html"><![CDATA[<p>列表解析式是将一个列表（实际上适用于任何<a href="https://docs.python.org/3/glossary.html#term-iterable" target="_blank" rel="noopener">可迭代对象（iterable）</a>）转换成另一个列表的工具。在转换过程中，可以指定元素必须符合一定的条件，才能添加至新的列表中，这样每个元素都可以按需要进行转换。</p><a id="more"></a><p>每个列表解析式都可以重写为for循环，但不是每个for循环都能重写为列表解析式。</p><h2 id="一、解析式介绍"><a href="#一、解析式介绍" class="headerlink" title="一、解析式介绍"></a>一、解析式介绍</h2><p>推导式：Comprehensions(又称解析式)。共有三种推导<strong>[a.列表解析 b.字典解析 c.集合解析]</strong>这三种都是python里面的语法糖(Syntactic Sugar)。</p><h2 id="二、列表解析式"><a href="#二、列表解析式" class="headerlink" title="二、列表解析式"></a>二、列表解析式</h2><p>列表解析的一般形式：</p><pre><code>[expression for item in iterable]  # [表达式 for 元素 可迭代对象]</code></pre><p>  示例：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>[<span class="number">2</span> ** n <span class="keyword">for</span> n <span class="keyword">in</span> range(<span class="number">10</span>)]</span><br><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">4</span>, <span class="number">8</span>, <span class="number">16</span>, <span class="number">32</span>, <span class="number">64</span>, <span class="number">128</span>, <span class="number">256</span>, <span class="number">512</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="function"><span class="keyword">def</span> <span class="title">inc</span><span class="params">(x)</span>:</span></span><br><span class="line">4<span class="keyword">return</span> x + <span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>[inc(x) <span class="keyword">for</span> x <span class="keyword">in</span> range(<span class="number">10</span>)]</span><br><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">10</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>[<span class="number">0</span> <span class="keyword">for</span> x <span class="keyword">in</span> range(<span class="number">10</span>)]</span><br><span class="line">[<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="function"><span class="keyword">def</span> <span class="title">non_return</span><span class="params">(x)</span>:</span></span><br><span class="line">4<span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>[non_return(x) <span class="keyword">for</span> x <span class="keyword">in</span> range(<span class="number">10</span>)]</span><br><span class="line">[<span class="keyword">None</span>, <span class="keyword">None</span>, <span class="keyword">None</span>, <span class="keyword">None</span>, <span class="keyword">None</span>, <span class="keyword">None</span>, <span class="keyword">None</span>, <span class="keyword">None</span>, <span class="keyword">None</span>, <span class="keyword">None</span>]</span><br></pre></td></tr></table></figure></p><p>  列表解析式返回的结果就是列表，列表的内容是表达式执行的结果。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>[x <span class="keyword">for</span> x <span class="keyword">in</span> range(<span class="number">10</span>) <span class="keyword">if</span> x % <span class="number">2</span> == <span class="number">0</span>]</span><br><span class="line">[<span class="number">0</span>, <span class="number">2</span>, <span class="number">4</span>, <span class="number">6</span>, <span class="number">8</span>]</span><br><span class="line"><span class="comment"># 上边的语句等效于</span></span><br><span class="line">ret = []</span><br><span class="line"><span class="keyword">for</span> x <span class="keyword">in</span> range(<span class="number">10</span>):</span><br><span class="line">    <span class="keyword">if</span> x % <span class="number">2</span> == <span class="number">0</span>:</span><br><span class="line">        ret.append(x)</span><br></pre></td></tr></table></figure><p>  可以用python的timeit 来测试两种方式的执行效率。会发现列表解析的执行效率会好。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> timeit</span><br><span class="line">list = []</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">fun</span><span class="params">()</span>:</span></span><br><span class="line">4<span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">100</span>):</span><br><span class="line">44<span class="keyword">if</span> i%<span class="number">2</span> == <span class="number">0</span>:</span><br><span class="line">444list.append(i)</span><br><span class="line">n = <span class="number">1000000</span></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">4print(timeit.timeit(stmt=fun, number=n))</span><br><span class="line">4print(timeit.timeit(stmt=<span class="string">"[x for x in range(100) if x%2 == 0]"</span>,number = n))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出结果</span></span><br><span class="line"><span class="number">22.620747613055016</span></span><br><span class="line"><span class="number">12.893759290163143</span></span><br><span class="line">[Finished <span class="keyword">in</span> <span class="number">37.0</span>s]</span><br></pre></td></tr></table></figure></p><p>如果列表解析式中有if关键字呢：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[expression <span class="keyword">for</span> item <span class="keyword">in</span> iterable <span class="keyword">if</span> condition]    <span class="comment"># [表达式 for 元素 in 可迭代对象 if 条件语句]</span></span><br><span class="line"><span class="comment"># 等价于</span></span><br><span class="line">ret = []</span><br><span class="line"><span class="keyword">for</span> item <span class="keyword">in</span> iterable:</span><br><span class="line"><span class="keyword">if</span> condition:</span><br><span class="line">    ret.append(exper)</span><br></pre></td></tr></table></figure></p><p>  以上介绍的只带了一个if关键字，如果有多个if关键字呢：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[experessi on <span class="keyword">for</span> item <span class="keyword">in</span> iterable <span class="keyword">if</span> condition1 <span class="keyword">if</span> condition2]</span><br><span class="line"><span class="comment"># 等价于</span></span><br><span class="line">ret = []</span><br><span class="line"><span class="keyword">for</span> item <span class="keyword">in</span> iterable:</span><br><span class="line">    <span class="keyword">if</span> condition1:</span><br><span class="line">        <span class="keyword">if</span> condition2:</span><br><span class="line">            ret.append(experession)</span><br></pre></td></tr></table></figure></p><p>  针对上面来个例子：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">[x <span class="keyword">for</span> x <span class="keyword">in</span> range(<span class="number">10</span>) <span class="keyword">if</span> x % <span class="number">2</span> == <span class="number">0</span> <span class="keyword">if</span> x &gt; <span class="number">1</span>]</span><br><span class="line">[<span class="number">2</span>, <span class="number">4</span>, <span class="number">6</span>, <span class="number">8</span>]</span><br><span class="line">    </span><br><span class="line"><span class="comment"># 再来个例子</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>[x <span class="keyword">for</span> x <span class="keyword">in</span> lst <span class="keyword">if</span> len(x) &gt; <span class="number">1</span> <span class="keyword">and</span> x.pop(<span class="number">0</span>) % <span class="number">2</span> == <span class="number">0</span>]</span><br><span class="line">[[<span class="number">1</span>], [<span class="number">3</span>]]</span><br><span class="line">    </span><br><span class="line"><span class="comment"># 不但可以有多个if关键字，还可以有多个for关键字，也就是嵌套循环</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>[(x, y) <span class="keyword">for</span> x <span class="keyword">in</span> range(<span class="number">3</span>) <span class="keyword">for</span> y <span class="keyword">in</span> range(<span class="number">3</span>)]</span><br><span class="line">[(<span class="number">0</span>, <span class="number">0</span>), (<span class="number">0</span>, <span class="number">1</span>), (<span class="number">0</span>, <span class="number">2</span>), (<span class="number">1</span>, <span class="number">0</span>), (<span class="number">1</span>, <span class="number">1</span>), (<span class="number">1</span>, <span class="number">2</span>), (<span class="number">2</span>, <span class="number">0</span>), (<span class="number">2</span>, <span class="number">1</span>), (<span class="number">2</span>, <span class="number">2</span>)]</span><br><span class="line">    </span><br><span class="line"><span class="comment"># 写成一个公式类的写法为：</span></span><br><span class="line">[expr <span class="keyword">for</span> item1 <span class="keyword">in</span> iterable1 <span class="keyword">for</span> item2 <span class="keyword">in</span> iterable2]</span><br><span class="line"><span class="comment"># 等价于</span></span><br><span class="line"><span class="keyword">for</span> item1 <span class="keyword">in</span> iterable1:</span><br><span class="line">    <span class="keyword">for</span> item2 <span class="keyword">in</span> iterable2:</span><br><span class="line">        <span class="keyword">for</span> y <span class="keyword">in</span> range(<span class="number">10</span>):</span><br><span class="line">            ret.append((x,y))</span><br><span class="line"><span class="comment"># 如果要在列表解析式中处理嵌套循环，请记住for循环子句的顺序与我们原来for循环的顺序是一致的。</span></span><br><span class="line"><span class="comment"># 所以可以实现一句话打印出九九乘法表</span></span><br><span class="line">print(<span class="string">'\n'</span>.join([<span class="string">' '</span>.join([<span class="string">'%s*%s=%s'</span> % (y,x,x*y) <span class="keyword">for</span> y <span class="keyword">in</span> range(<span class="number">1</span>,x+<span class="number">1</span>)]) <span class="keyword">for</span> x <span class="keyword">in</span> range(<span class="number">1</span>,<span class="number">10</span>)]))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 这个乘法表列表解析式 读起来很困难，python支持在括号和花括号之间断行。</span></span><br><span class="line">print(<span class="string">'\n'</span>.join([<span class="string">' '</span>.join([</span><br><span class="line">    <span class="string">'%s*%s=%s'</span> % (y,x,x*y)</span><br><span class="line">    <span class="keyword">for</span> y <span class="keyword">in</span> range(<span class="number">1</span>,x+<span class="number">1</span>)])</span><br><span class="line">    <span class="keyword">for</span> x <span class="keyword">in</span> range(<span class="number">1</span>,<span class="number">10</span>)]))</span><br></pre></td></tr></table></figure></p><p>  那么for与if都有呢？多个for语句相当于逐层for嵌套。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>[(x, y) <span class="keyword">for</span> x <span class="keyword">in</span> range(<span class="number">5</span>) <span class="keyword">for</span> y <span class="keyword">in</span> range(<span class="number">5</span>) <span class="keyword">if</span> (x+y)%<span class="number">2</span>==<span class="number">0</span>]</span><br><span class="line">[(<span class="number">0</span>, <span class="number">0</span>), (<span class="number">0</span>, <span class="number">2</span>), (<span class="number">0</span>, <span class="number">4</span>), (<span class="number">1</span>, <span class="number">1</span>), (<span class="number">1</span>, <span class="number">3</span>), (<span class="number">2</span>, <span class="number">0</span>), (<span class="number">2</span>, <span class="number">2</span>), (<span class="number">2</span>, <span class="number">4</span>), (<span class="number">3</span>, <span class="number">1</span>), (<span class="number">3</span>, <span class="number">3</span>), (<span class="number">4</span>, <span class="number">0</span>), (<span class="number">4</span>, <span class="number">2</span>), (<span class="number">4</span>, <span class="number">4</span>)]</span><br><span class="line">    <span class="comment"># 等价于</span></span><br><span class="line">list = []</span><br><span class="line"><span class="keyword">for</span> x <span class="keyword">in</span> range(<span class="number">10</span>):</span><br><span class="line">    <span class="keyword">if</span> x % <span class="number">2</span> == <span class="number">0</span>:</span><br><span class="line">        <span class="keyword">for</span> y <span class="keyword">in</span> range(<span class="number">10</span>):</span><br><span class="line">            ret.append((x,y))</span><br></pre></td></tr></table></figure></p><p>  如果for关键字不在第一个位置，会不会出现问题？<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>[x <span class="keyword">if</span> <span class="keyword">True</span> <span class="keyword">for</span> x <span class="keyword">in</span> range(<span class="number">10</span>)]</span><br><span class="line">SyntaxError: invalid syntax</span><br></pre></td></tr></table></figure></p><p>  因此，for关键字要写在前面，后面可以用for或if进行嵌套<br>  多看几个例子：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>[(x+<span class="number">1</span>, x+<span class="number">2</span>) <span class="keyword">for</span> x <span class="keyword">in</span> range(<span class="number">5</span>)]</span><br><span class="line">[(<span class="number">1</span>, <span class="number">2</span>), (<span class="number">2</span>, <span class="number">3</span>), (<span class="number">3</span>, <span class="number">4</span>), (<span class="number">4</span>, <span class="number">5</span>), (<span class="number">5</span>, <span class="number">6</span>)]</span><br><span class="line">    </span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>[&#123;x+<span class="number">1</span>:x+<span class="number">2</span>&#125; <span class="keyword">for</span> x <span class="keyword">in</span> range(<span class="number">5</span>)]</span><br><span class="line">[&#123;<span class="number">1</span>: <span class="number">2</span>&#125;, &#123;<span class="number">2</span>: <span class="number">3</span>&#125;, &#123;<span class="number">3</span>: <span class="number">4</span>&#125;, &#123;<span class="number">4</span>: <span class="number">5</span>&#125;, &#123;<span class="number">5</span>: <span class="number">6</span>&#125;]</span><br></pre></td></tr></table></figure></p><p>  列表解析可用于可迭代对象做过滤和转换，返回值是列表。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">help(filter)</span><br><span class="line">filter(<span class="keyword">lambda</span> x: x % <span class="number">2</span> == <span class="number">0</span>, range(<span class="number">10</span>))</span><br><span class="line">list(filter(<span class="keyword">lambda</span> x: x % <span class="number">2</span> == <span class="number">0</span>, range(<span class="number">10</span>)))</span><br><span class="line">help(map)</span><br><span class="line">list(map(<span class="keyword">lambda</span> x: x+<span class="number">1</span>, range(<span class="number">10</span>)))</span><br><span class="line">[x+<span class="number">1</span> <span class="keyword">for</span> x <span class="keyword">in</span> range(<span class="number">10</span>)]</span><br><span class="line"><span class="comment"># Python里，可以不用filter及map函数，使用列表解析式可以秒杀filter及map</span></span><br><span class="line"><span class="comment"># 上面的话并不是绝对的，当数据比较大时，使用filter及map将会比列表解析式快</span></span><br></pre></td></tr></table></figure></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">在Python中，<span class="keyword">lambda</span>的语法是唯一的。其形式如下：</span><br><span class="line"><span class="keyword">lambda</span> argument_list: expression</span><br><span class="line">其中，<span class="keyword">lambda</span>是Python预留的关键字，argument_list和expression由用户自定义。这里的argument_list是参数列表。它的结构与Python中函数(function)的参数列表是一样的。</span><br><span class="line"> 例如：</span><br><span class="line"><span class="keyword">lambda</span> x, y: xy；     <span class="comment">#函数输入是x和y，输出是它们的积xy</span></span><br><span class="line"><span class="keyword">lambda</span>:<span class="keyword">None</span>；         <span class="comment">#函数没有输入参数，输出是None</span></span><br><span class="line"><span class="keyword">lambda</span> *args: sum(args);  <span class="comment">#输入是任意个数的参数，输出是它们的和(隐性要求是输入参数必须能够进行加法运算)</span></span><br><span class="line"><span class="keyword">lambda</span> **kwages: <span class="number">1</span>;    <span class="comment">#输入是任意键值对参数， 输出是1</span></span><br></pre></td></tr></table></figure><p>再来看一个例子，偶数求平方，奇数求立方。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>lst = list(range(<span class="number">10</span>))</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>[x ** <span class="number">2</span> <span class="keyword">if</span> x % <span class="number">2</span> == <span class="number">0</span> <span class="keyword">else</span> x ** <span class="number">3</span> <span class="keyword">for</span> x <span class="keyword">in</span> lst]</span><br><span class="line">[<span class="number">0</span>, <span class="number">1</span>, <span class="number">4</span>, <span class="number">27</span>, <span class="number">16</span>, <span class="number">125</span>, <span class="number">36</span>, <span class="number">343</span>, <span class="number">64</span>, <span class="number">729</span>]</span><br></pre></td></tr></table></figure></p><p>  总结上述代码：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">x <span class="keyword">if</span> condition <span class="keyword">else</span> y    <span class="comment"># 当条件满足时返回x,当条件不满足时返回y。</span></span><br></pre></td></tr></table></figure></p><h2 id="三、字典解析式"><a href="#三、字典解析式" class="headerlink" title="三、字典解析式"></a>三、字典解析式</h2><p>   字典解析也需要一个大括号，并且要有两个表达式：一个生成key，一个生成value；两个表达式之间使用冒号分隔，返回结果是字典。示例：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>print(&#123;str(x):x <span class="keyword">for</span> x <span class="keyword">in</span> range(<span class="number">10</span>)&#125;)</span><br><span class="line">&#123;<span class="string">'0'</span>: <span class="number">0</span>, <span class="string">'1'</span>: <span class="number">1</span>, <span class="string">'2'</span>: <span class="number">2</span>, <span class="string">'3'</span>: <span class="number">3</span>, <span class="string">'4'</span>: <span class="number">4</span>, <span class="string">'5'</span>: <span class="number">5</span>, <span class="string">'6'</span>: <span class="number">6</span>, <span class="string">'7'</span>: <span class="number">7</span>, <span class="string">'8'</span>: <span class="number">8</span>, <span class="string">'9'</span>: <span class="number">9</span>&#125;</span><br></pre></td></tr></table></figure></p><p>看一个例子：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>&#123;str(x):y <span class="keyword">for</span> x <span class="keyword">in</span> range(<span class="number">3</span>) <span class="keyword">for</span> y <span class="keyword">in</span> range(<span class="number">4</span>)&#125;  <span class="comment"># 取决于短的那个</span></span><br><span class="line">&#123;<span class="string">'0'</span>: <span class="number">3</span>, <span class="string">'1'</span>: <span class="number">3</span>, <span class="string">'2'</span>: <span class="number">3</span>&#125;</span><br><span class="line"><span class="comment"># 等价于</span></span><br><span class="line">ret = &#123;&#125;</span><br><span class="line"><span class="keyword">for</span> x <span class="keyword">in</span> range(<span class="number">3</span>):</span><br><span class="line">    <span class="keyword">for</span> y <span class="keyword">in</span> range(<span class="number">4</span>):</span><br><span class="line">        ret[str(x)] = y</span><br><span class="line">print(ret)</span><br></pre></td></tr></table></figure></p><h2 id="四、集合解析式"><a href="#四、集合解析式" class="headerlink" title="四、集合解析式"></a>四、集合解析式</h2><p>   集合解析把列表解析的中括号变成大括号，返回集合。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>&#123;str(x):y <span class="keyword">for</span> x <span class="keyword">in</span> range(<span class="number">3</span>) <span class="keyword">for</span> y <span class="keyword">in</span> range(<span class="number">4</span>)&#125;     </span><br><span class="line">&#123;<span class="string">'0'</span>: <span class="number">3</span>, <span class="string">'1'</span>: <span class="number">3</span>, <span class="string">'2'</span>: <span class="number">3</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>&#123;x <span class="keyword">for</span> x <span class="keyword">in</span> range(<span class="number">10</span>)&#125;</span><br><span class="line">&#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>set01 = &#123;x <span class="keyword">for</span> x <span class="keyword">in</span> range(<span class="number">10</span>)&#125;</span><br><span class="line">     </span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>set01     </span><br><span class="line">&#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>type(set01)     </span><br><span class="line">&lt;<span class="class"><span class="keyword">class</span> '<span class="title">set</span>'&gt;</span></span><br><span class="line"><span class="class">`</span></span><br></pre></td></tr></table></figure></p><p><a href="https://www.52pojie.cn/thread-874792-1-1.html" target="_blank" rel="noopener">参考链接</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;列表解析式是将一个列表（实际上适用于任何&lt;a href=&quot;https://docs.python.org/3/glossary.html#term-iterable&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;可迭代对象（iterable）&lt;/a&gt;）转换成另一个列表的工具。在转换过程中，可以指定元素必须符合一定的条件，才能添加至新的列表中，这样每个元素都可以按需要进行转换。&lt;/p&gt;
    
    </summary>
    
      <category term="python" scheme="http://yoursite.com/categories/python/"/>
    
    
      <category term="python" scheme="http://yoursite.com/tags/python/"/>
    
  </entry>
  
  <entry>
    <title>有效的括号</title>
    <link href="http://yoursite.com/2019/04/07/%E6%9C%89%E6%95%88%E7%9A%84%E6%8B%AC%E5%8F%B7/"/>
    <id>http://yoursite.com/2019/04/07/有效的括号/</id>
    <published>2019-04-07T07:29:25.000Z</published>
    <updated>2019-04-19T08:20:11.299Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://leetcode-cn.com/problems/valid-parentheses/comments/" target="_blank" rel="noopener">20有效的括号</a>  </p><blockquote><p><em>题目描述：</em><br><em>给定一个只包括 ‘(‘，’)’，’{‘，’}’，’[‘，’]’ 的字符串，判断字符串是否有效。</em><br><em>有效字符串需满足：</em><br><em>左括号必须用相同类型的右括号闭合。</em><br><em>左括号必须以正确的顺序闭合</em><br>注意空字符串可被认为是有效字符串。* </p></blockquote><a id="more"></a><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">isValid</span><span class="params">(self, s)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type s: str</span></span><br><span class="line"><span class="string">        :rtype: bool</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="comment"># 排除必错的逻辑</span></span><br><span class="line">        <span class="keyword">if</span> len(s)==<span class="number">1</span> <span class="keyword">and</span> (s==<span class="string">')'</span> <span class="keyword">or</span> s==<span class="string">'&#125;'</span> <span class="keyword">or</span> s==<span class="string">']'</span>):</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">False</span></span><br><span class="line"></span><br><span class="line">        L=[]</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> s:</span><br><span class="line">            <span class="keyword">if</span> i == <span class="string">'('</span> <span class="keyword">or</span> i == <span class="string">'&#123;'</span> <span class="keyword">or</span> i == <span class="string">'['</span>:</span><br><span class="line">                L.append(i)</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (i==<span class="string">')'</span> <span class="keyword">or</span> i==<span class="string">'&#125;'</span> <span class="keyword">or</span> i==<span class="string">']'</span>) <span class="keyword">and</span> L:</span><br><span class="line">                temp=L.pop()</span><br><span class="line">                <span class="keyword">if</span> i==<span class="string">')'</span> <span class="keyword">and</span> temp!=<span class="string">'('</span>:</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">False</span></span><br><span class="line">                <span class="keyword">if</span> i==<span class="string">'&#125;'</span> <span class="keyword">and</span> temp!=<span class="string">'&#123;'</span>:</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">False</span></span><br><span class="line">                <span class="keyword">if</span> i==<span class="string">']'</span> <span class="keyword">and</span> temp!=<span class="string">'['</span>:</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">False</span></span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (i == <span class="string">')'</span> <span class="keyword">or</span> i == <span class="string">'&#125;'</span> <span class="keyword">or</span> i == <span class="string">']'</span>) <span class="keyword">and</span> <span class="keyword">not</span> L:</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">False</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> L:</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">False</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">True</span></span><br></pre></td></tr></table></figure><hr><p>大佬的方案<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">isValid</span><span class="params">(self, s)</span>:</span></span><br><span class="line">        <span class="keyword">while</span> <span class="string">'&#123;&#125;'</span> <span class="keyword">in</span> s <span class="keyword">or</span> <span class="string">'()'</span> <span class="keyword">in</span> s <span class="keyword">or</span> <span class="string">'[]'</span> <span class="keyword">in</span> s:</span><br><span class="line">            s = s.replace(<span class="string">'&#123;&#125;'</span>, <span class="string">''</span>)</span><br><span class="line">            s = s.replace(<span class="string">'[]'</span>, <span class="string">''</span>)</span><br><span class="line">            s = s.replace(<span class="string">'()'</span>, <span class="string">''</span>)</span><br><span class="line">        <span class="keyword">return</span> s == <span class="string">''</span></span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;a href=&quot;https://leetcode-cn.com/problems/valid-parentheses/comments/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;20有效的括号&lt;/a&gt;  &lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;em&gt;题目描述：&lt;/em&gt;&lt;br&gt;&lt;em&gt;给定一个只包括 ‘(‘，’)’，’{‘，’}’，’[‘，’]’ 的字符串，判断字符串是否有效。&lt;/em&gt;&lt;br&gt;&lt;em&gt;有效字符串需满足：&lt;/em&gt;&lt;br&gt;&lt;em&gt;左括号必须用相同类型的右括号闭合。&lt;/em&gt;&lt;br&gt;&lt;em&gt;左括号必须以正确的顺序闭合&lt;/em&gt;&lt;br&gt;注意空字符串可被认为是有效字符串。* &lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="leecode" scheme="http://yoursite.com/categories/leecode/"/>
    
    
      <category term="stack" scheme="http://yoursite.com/tags/stack/"/>
    
  </entry>
  
  <entry>
    <title>字符串解码</title>
    <link href="http://yoursite.com/2019/04/05/%E5%AD%97%E7%AC%A6%E4%B8%B2%E8%A7%A3%E7%A0%81/"/>
    <id>http://yoursite.com/2019/04/05/字符串解码/</id>
    <published>2019-04-05T07:22:50.000Z</published>
    <updated>2019-04-19T08:36:26.584Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://leetcode-cn.com/problems/decode-string/" target="_blank" rel="noopener">394.字符串解码</a></p><blockquote><p><em>题目描述：</em><br><em>给定一个经过编码的字符串，返回它解码后的字符串。</em><br><em>编码规则为: k[encoded_string]，表示其中方括号内部的 encoded_string 正好重复 k 次。注意 k 保证为正整数。</em><br><em>你可以认为输入字符串总是有效的；输入字符串中没有额外的空格，且输入的方括号总是符合格式要求的。</em><br><em>此外，你可以认为原始数据不包含数字，所有的数字只表示重复的次数 k ，例如不会出现像 3a 或 2[4] 的输入。</em></p></blockquote><a id="more"></a><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string">这个题吧，一开始想着以为用递归，一直递归不出来。</span></span><br><span class="line"><span class="string">看了别人的，发现用栈好点</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">decodeString</span><span class="params">(self, s)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type s: str</span></span><br><span class="line"><span class="string">        :rtype: str</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        stack = []</span><br><span class="line">        curNum = <span class="number">0</span></span><br><span class="line">        curString = <span class="string">''</span></span><br><span class="line">        <span class="keyword">for</span> c <span class="keyword">in</span> s:</span><br><span class="line">            <span class="keyword">if</span> c == <span class="string">'['</span>:</span><br><span class="line">                stack.append(curString)</span><br><span class="line">                stack.append(curNum)</span><br><span class="line">                curString = <span class="string">''</span></span><br><span class="line">                curNum = <span class="number">0</span></span><br><span class="line">            <span class="keyword">elif</span> c == <span class="string">']'</span>:</span><br><span class="line">                num = stack.pop()</span><br><span class="line">                prevString = stack.pop()</span><br><span class="line">                curString = prevString + num*curString</span><br><span class="line">            <span class="keyword">elif</span> c.isdigit():</span><br><span class="line">                curNum = curNum*<span class="number">10</span> + int(c)</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                curString += c</span><br><span class="line">        <span class="keyword">return</span> curString</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;a href=&quot;https://leetcode-cn.com/problems/decode-string/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;394.字符串解码&lt;/a&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;em&gt;题目描述：&lt;/em&gt;&lt;br&gt;&lt;em&gt;给定一个经过编码的字符串，返回它解码后的字符串。&lt;/em&gt;&lt;br&gt;&lt;em&gt;编码规则为: k[encoded_string]，表示其中方括号内部的 encoded_string 正好重复 k 次。注意 k 保证为正整数。&lt;/em&gt;&lt;br&gt;&lt;em&gt;你可以认为输入字符串总是有效的；输入字符串中没有额外的空格，且输入的方括号总是符合格式要求的。&lt;/em&gt;&lt;br&gt;&lt;em&gt;此外，你可以认为原始数据不包含数字，所有的数字只表示重复的次数 k ，例如不会出现像 3a 或 2[4] 的输入。&lt;/em&gt;&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="leecode" scheme="http://yoursite.com/categories/leecode/"/>
    
    
      <category term="stack" scheme="http://yoursite.com/tags/stack/"/>
    
  </entry>
  
  <entry>
    <title>最小栈</title>
    <link href="http://yoursite.com/2019/04/04/%E6%9C%80%E5%B0%8F%E6%A0%88/"/>
    <id>http://yoursite.com/2019/04/04/最小栈/</id>
    <published>2019-04-04T12:31:45.000Z</published>
    <updated>2019-04-19T08:21:52.613Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://leetcode-cn.com/problems/min-stack/" target="_blank" rel="noopener">最小栈</a>  </p><blockquote><p><em>题目描述：</em><br><em>设计一个支持 push，pop，top 操作，并能在常数时间内检索到最小元素的栈。<br>push(x) – 将元素 x 推入栈中。<br>pop() – 删除栈顶的元素。<br>top() – 获取栈顶元素。<br>getMin() – 检索栈中的最小元素。</em><br><a id="more"></a><br>思路：入栈时靠辅助栈记住主栈元素中最小的，出栈时一直pop主栈元素直到辅助栈栈顶元素出现。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MinStack</span><span class="params">(object)</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="comment"># 初始化你的数据结构</span></span><br><span class="line">        self.stack = []</span><br><span class="line">        </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">push</span><span class="params">(self, x)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> x <span class="keyword">is</span> <span class="keyword">None</span>:</span><br><span class="line">            <span class="keyword">pass</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            self.stack.append(x)</span><br><span class="line">        </span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">pop</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="comment"># 首先判断列表是否为空</span></span><br><span class="line">        <span class="keyword">if</span> self.stack <span class="keyword">is</span> <span class="keyword">None</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="string">'None'</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            self.stack.pop(<span class="number">-1</span>)</span><br><span class="line">        </span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">top</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> self.stack <span class="keyword">is</span> <span class="keyword">None</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="string">'None'</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> self.stack[<span class="number">-1</span>]</span><br><span class="line">        </span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">getMin</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> self.stack <span class="keyword">is</span> <span class="keyword">None</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="string">'None'</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> min(self.stack)</span><br></pre></td></tr></table></figure></p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;a href=&quot;https://leetcode-cn.com/problems/min-stack/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;最小栈&lt;/a&gt;  &lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;em&gt;题目描述：&lt;/em&gt;&lt;br&gt;&lt;em&gt;设计一个支持 push，pop，top 操作，并能在常数时间内检索到最小元素的栈。&lt;br&gt;push(x) – 将元素 x 推入栈中。&lt;br&gt;pop() – 删除栈顶的元素。&lt;br&gt;top() – 获取栈顶元素。&lt;br&gt;getMin() – 检索栈中的最小元素。&lt;/em&gt;&lt;br&gt;
    
    </summary>
    
      <category term="leecode" scheme="http://yoursite.com/categories/leecode/"/>
    
    
      <category term="stack" scheme="http://yoursite.com/tags/stack/"/>
    
  </entry>
  
  <entry>
    <title>二叉树的遍历</title>
    <link href="http://yoursite.com/2019/04/02/%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E9%81%8D%E5%8E%86/"/>
    <id>http://yoursite.com/2019/04/02/二叉树的遍历/</id>
    <published>2019-04-02T02:21:52.000Z</published>
    <updated>2019-04-16T03:27:07.184Z</updated>
    
    <content type="html"><![CDATA[<p> <a href="https://leetcode-cn.com/problems/binary-tree-preorder-traversal/" target="_blank" rel="noopener">二叉树的前序遍历</a></p><blockquote><p>思路：</p><ol><li>使用列表保存结果；</li><li>使用栈（列表实现）存储结点；</li><li>当根结点存在，保存结果，根结点入栈；</li><li>将根结点指向左子树；</li><li>根结点不存在，栈顶元素出栈，并将根结点指向栈顶元素的右子树；</li><li>重复步骤3-6，直到栈空。</li></ol></blockquote><a id="more"></a><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"># class TreeNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, x):</span></span><br><span class="line"><span class="comment">#         self.val = x</span></span><br><span class="line"><span class="comment">#         self.left = None</span></span><br><span class="line"><span class="comment">#         self.right = None</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">4<span class="function"><span class="keyword">def</span> <span class="title">preorderTraversal</span><span class="params">(self, root: TreeNode)</span> -&gt; List[int]:</span></span><br><span class="line">    stack = [] <span class="comment"># 非递归前序遍历，需要借助栈(列表)</span></span><br><span class="line">        res = [] <span class="comment"># 输出</span></span><br><span class="line">        <span class="comment"># 树为空</span></span><br><span class="line">        <span class="keyword">if</span>  root == <span class="keyword">None</span>:</span><br><span class="line">            <span class="keyword">return</span> res</span><br><span class="line">        <span class="comment"># 树不为空，将根节点压入栈中，然后循环</span></span><br><span class="line">        stack.append(root)</span><br><span class="line">       <span class="comment"># 循环</span></span><br><span class="line">        <span class="keyword">while</span> stack:</span><br><span class="line">        top = stack.pop()</span><br><span class="line">            <span class="comment"># 孩子结点不为空，将孩子结点压入栈，一定是先压右孩子再压左孩子</span></span><br><span class="line">        <span class="keyword">if</span> top.right != <span class="keyword">None</span>:</span><br><span class="line">                stack.append(top.right)</span><br><span class="line">        <span class="keyword">if</span> top.left !=<span class="keyword">None</span>:</span><br><span class="line">            stack.append(top.left)</span><br><span class="line">            res.append(top.val)</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure><p><a href="https://leetcode-cn.com/problems/binary-tree-inorder-traversal/" target="_blank" rel="noopener">二叉树的中序遍历</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt; &lt;a href=&quot;https://leetcode-cn.com/problems/binary-tree-preorder-traversal/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;二叉树的前序遍历&lt;/a&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;思路：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;使用列表保存结果；&lt;/li&gt;
&lt;li&gt;使用栈（列表实现）存储结点；&lt;/li&gt;
&lt;li&gt;当根结点存在，保存结果，根结点入栈；&lt;/li&gt;
&lt;li&gt;将根结点指向左子树；&lt;/li&gt;
&lt;li&gt;根结点不存在，栈顶元素出栈，并将根结点指向栈顶元素的右子树；&lt;/li&gt;
&lt;li&gt;重复步骤3-6，直到栈空。&lt;/li&gt;
&lt;/ol&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="leecode" scheme="http://yoursite.com/categories/leecode/"/>
    
    
      <category term="stack" scheme="http://yoursite.com/tags/stack/"/>
    
      <category term="tree" scheme="http://yoursite.com/tags/tree/"/>
    
  </entry>
  
  <entry>
    <title>棒球比赛</title>
    <link href="http://yoursite.com/2019/04/01/%E6%A3%92%E7%90%83%E6%AF%94%E8%B5%9B/"/>
    <id>http://yoursite.com/2019/04/01/棒球比赛/</id>
    <published>2019-04-01T13:19:53.000Z</published>
    <updated>2019-04-19T07:56:07.005Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://leetcode-cn.com/problems/baseball-game/" target="_blank" rel="noopener">682.棒球比赛</a></p><blockquote><p><em>题目描述：</em><br><em>你现在是棒球比赛记录员。</em><br><em>给定一个字符串列表，每个字符串可以是以下四种类型之一：</em> </p><p><em>1.整数（一轮的得分）：直接表示您在本轮中获得的积分数。</em></p><p><em>2.”+”（一轮的得分）：表示本轮获得的得分是前两轮有效 回合得分的总和。</em> </p><p><em>3.”D”（一轮的得分）：表示本轮获得的得分是前一轮有效 回合得分的两倍。</em></p><p><em>4.”C”（一个操作，这不是一个回合的分数）：表示您获得的最后一个有效 回合的分数是无效的，应该被移除。</em><br><em>每一轮的操作都是永久性的，可能会对前一轮和后一轮产生影响。</em><br><em>你需要返回你在所有回合中得分的总和。</em> </p></blockquote><a id="more"></a><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">4<span class="string">'''处理数据时保持栈上每个回合的有效值</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line">4<span class="function"><span class="keyword">def</span> <span class="title">calPoints</span><span class="params">(self, ops)</span>:</span></span><br><span class="line">44stack = [] <span class="comment"># 声明一个空栈</span></span><br><span class="line">44<span class="keyword">for</span> x <span class="keyword">in</span> ops:</span><br><span class="line">444<span class="keyword">if</span> x == <span class="string">'+'</span>:</span><br><span class="line">4444stack.append(stack[<span class="number">-1</span>] + stack[<span class="number">-2</span>])</span><br><span class="line">444<span class="keyword">elif</span> x == <span class="string">'C'</span>:</span><br><span class="line">4444stack.pop()</span><br><span class="line">444<span class="keyword">elif</span> x == <span class="string">'D'</span>:</span><br><span class="line">4444stack.append(<span class="number">2</span> * stack[<span class="number">-1</span>])</span><br><span class="line">444<span class="keyword">else</span>:</span><br><span class="line">4444stack.append(int(x))</span><br><span class="line">44<span class="comment"># 返回栈中值的和</span></span><br><span class="line">44<span class="keyword">return</span> sum(stack)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 测试一下</span></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">4test_list = [<span class="string">"5"</span>,<span class="string">"-2"</span>,<span class="string">"4"</span>,<span class="string">"C"</span>,<span class="string">"D"</span>,<span class="string">"9"</span>,<span class="string">"+"</span>,<span class="string">"+"</span>]</span><br><span class="line">4test = Solution()</span><br><span class="line">4result = test.calPoints(test_list)</span><br><span class="line">4print(result)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 结果 27</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;a href=&quot;https://leetcode-cn.com/problems/baseball-game/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;682.棒球比赛&lt;/a&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;em&gt;题目描述：&lt;/em&gt;&lt;br&gt;&lt;em&gt;你现在是棒球比赛记录员。&lt;/em&gt;&lt;br&gt;&lt;em&gt;给定一个字符串列表，每个字符串可以是以下四种类型之一：&lt;/em&gt; &lt;/p&gt;
&lt;p&gt;&lt;em&gt;1.整数（一轮的得分）：直接表示您在本轮中获得的积分数。&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;2.”+”（一轮的得分）：表示本轮获得的得分是前两轮有效 回合得分的总和。&lt;/em&gt; &lt;/p&gt;
&lt;p&gt;&lt;em&gt;3.”D”（一轮的得分）：表示本轮获得的得分是前一轮有效 回合得分的两倍。&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;4.”C”（一个操作，这不是一个回合的分数）：表示您获得的最后一个有效 回合的分数是无效的，应该被移除。&lt;/em&gt;&lt;br&gt;&lt;em&gt;每一轮的操作都是永久性的，可能会对前一轮和后一轮产生影响。&lt;/em&gt;&lt;br&gt;&lt;em&gt;你需要返回你在所有回合中得分的总和。&lt;/em&gt; &lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="leecode" scheme="http://yoursite.com/categories/leecode/"/>
    
    
      <category term="stack" scheme="http://yoursite.com/tags/stack/"/>
    
  </entry>
  
  <entry>
    <title>用栈实现队列</title>
    <link href="http://yoursite.com/2019/03/31/%E7%94%A8%E6%A0%88%E5%AE%9E%E7%8E%B0%E9%98%9F%E5%88%97/"/>
    <id>http://yoursite.com/2019/03/31/用栈实现队列/</id>
    <published>2019-03-31T12:11:07.000Z</published>
    <updated>2019-04-19T07:56:51.590Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://leetcode-cn.com/problems/implement-queue-using-stacks/" target="_blank" rel="noopener">232.用栈实现队列</a></p><pre><code>题目描述：使用栈实现队列的下列操作：push(x) -- 将一个元素放入队列的尾部。pop() -- 从队列首部移除元素。peek() -- 返回队列首部的元素。empty() -- 返回队列是否为空。</code></pre><a id="more"></a><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyQueue</span>:</span></span><br><span class="line">    <span class="string">'''</span></span><br><span class="line"><span class="string">    使用list 来模拟栈</span></span><br><span class="line"><span class="string">    两个堆栈input和output模拟队列，output栈必须清空才可以添加input中的值</span></span><br><span class="line"><span class="string">    入队列：向input 中压入元素</span></span><br><span class="line"><span class="string">    出队列：input队列元素依次弹出堆栈，并压入output中，最后弹出output的栈顶元素</span></span><br><span class="line"><span class="string">    '''</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="comment"># 初始化数据结构.</span></span><br><span class="line">        self.input = []</span><br><span class="line">        self.output = []</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">push</span><span class="params">(self, x)</span>:</span></span><br><span class="line">        <span class="comment"># 入队.将元素放入input 中</span></span><br><span class="line">        self.input.append(x)</span><br><span class="line">        </span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">pop</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="comment"># 从队列前面删除元素并返回该元素.</span></span><br><span class="line">        <span class="comment"># 首先判断output栈是否为空，不为空则直接弹出</span></span><br><span class="line">        <span class="keyword">if</span> self.output:</span><br><span class="line">            <span class="keyword">return</span> self.output.pop()</span><br><span class="line">        <span class="comment"># 为空则将input 中的数据全部放到output中</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">while</span> self.input:</span><br><span class="line">                self.output.append(self.input.pop())</span><br><span class="line">            <span class="keyword">return</span> self.output.pop()</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">peek</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="comment"># 获取前面的元素.</span></span><br><span class="line">        <span class="keyword">while</span> <span class="keyword">not</span> self.output:</span><br><span class="line">            <span class="keyword">while</span> self.input:</span><br><span class="line">                self.output.append(self.input.pop())</span><br><span class="line">        <span class="keyword">return</span> self.output[<span class="number">-1</span>]</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">empty</span><span class="params">(self)</span>:</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># 返回队列是否为空</span></span><br><span class="line">        <span class="keyword">if</span> self.input <span class="keyword">or</span> self.output:</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">False</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">True</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 可以测试一下</span></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    test_list = list(range(<span class="number">5</span>)) <span class="comment"># 生成一个列表</span></span><br><span class="line">    test_MyQueue = MyQueue()</span><br><span class="line">    <span class="comment"># 入队</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">5</span>):</span><br><span class="line">        test_MyQueue.push(test_list[i])</span><br><span class="line">    print(test_list) </span><br><span class="line">    <span class="comment"># 出队</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">5</span>):</span><br><span class="line">        print(test_MyQueue.pop(),<span class="string">','</span>,end=<span class="string">''</span>)</span><br><span class="line"></span><br><span class="line"><span class="string">"""输出结果</span></span><br><span class="line"><span class="string">[0, 1, 2, 3, 4]</span></span><br><span class="line"><span class="string">0 ,1 ,2 ,3 ,4 ,[Finished in 0.4s]</span></span><br><span class="line"><span class="string">"""</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;a href=&quot;https://leetcode-cn.com/problems/implement-queue-using-stacks/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;232.用栈实现队列&lt;/a&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;题目描述：
使用栈实现队列的下列操作：
push(x) -- 将一个元素放入队列的尾部。
pop() -- 从队列首部移除元素。
peek() -- 返回队列首部的元素。
empty() -- 返回队列是否为空。
&lt;/code&gt;&lt;/pre&gt;
    
    </summary>
    
      <category term="leecode" scheme="http://yoursite.com/categories/leecode/"/>
    
    
      <category term="stack" scheme="http://yoursite.com/tags/stack/"/>
    
  </entry>
  
  <entry>
    <title>tcp_ip_2</title>
    <link href="http://yoursite.com/2019/03/06/tcp_ip_2/"/>
    <id>http://yoursite.com/2019/03/06/tcp_ip_2/</id>
    <published>2019-03-06T02:16:17.000Z</published>
    <updated>2019-04-18T14:30:52.746Z</updated>
    
    <content type="html"><![CDATA[<h4 id="socket简介"><a href="#socket简介" class="headerlink" title="socket简介"></a>socket简介<a id="more"></a></h4><h4 id="1-不同电脑上的进程之间如何通信"><a href="#1-不同电脑上的进程之间如何通信" class="headerlink" title="1. 不同电脑上的进程之间如何通信"></a>1. 不同电脑上的进程之间如何通信</h4><p>首要解决的问题是如何唯一标识一个进程，否则通信无从谈起！</p><p>在1台电脑上可以通过进程号（PID）来唯一标识一个进程，但是在网络中这是行不通的。</p><p>其实TCP/IP协议族已经帮我们解决了这个问题，网络层的“ip地址”可以唯一标识网络中的主机，而传输层的“协议+端口”可以唯一标识主机中的应用进程（进程）。</p><p>这样利用ip地址，协议，端口就可以标识网络的进程了，网络中的进程通信就可以利用这个标志与其它进程进行交互</p><h5 id="注意："><a href="#注意：" class="headerlink" title="注意："></a>注意：</h5><blockquote><ul><li>所谓<code>进程</code>指的是：运行的程序以及运行时用到的资源这个整体称之为进程</li><li>所谓<code>进程间通信</code>指的是：运行的程序之间的数据共享</li></ul></blockquote><h3 id="2-什么是socket"><a href="#2-什么是socket" class="headerlink" title="2. 什么是socket"></a>2. 什么是socket</h3><p>socket(简称 <code>套接字</code>) 是进程间通信的一种方式，socket是一个抽象层，它把TCP/IP层复杂的操作抽象为几个简单的接口供应用层调用已实现进程在网络中通信。</p><p>socket起源于UNIX，在Unix一切皆文件思想下，socket是一种”打开—读/写—关闭”模式的实现，服务器和客户端各自维护一个”文件”，在建立连接打开后，可以向自己文件写入内容供对方读取或者读取对方内容，通讯结束时关闭文件。</p><p>它能实现不同主机间的进程间通信，我们网络上各种各样的服务大多都是基于 Socket 来完成通信的</p><p>例如我们每天浏览网页、QQ 聊天、收发 email 等等。</p><p>socket 通信流程：</p><p>socket是”打开—读/写—关闭”模式的实现，以使用TCP协议通讯的socket为例，其交互流程大概是这样子的：</p><ol><li><em>服务器根据地址类型（ipv4,ipv6）、socket类型、协议创建socket</em></li><li><em>服务器为socket绑定ip地址和端口号</em></li><li><em>服务器socket监听端口号请求，随时准备接收客户端发来的连接，这时候服务器的socket并没有被打开</em></li><li><em>客户端创建socket</em></li><li><em>客户端打开socket，根据服务器ip地址和端口号试图连接服务器socket</em></li><li><em>服务器socket接收到客户端socket请求，被动打开，开始接收客户端请求，直到客户端返回连接信息。这时候socket进入<strong>阻塞</strong>状态，所谓阻塞即accept()方法一直到客户端返回连接信息后才返回，开始接收下一个客户端谅解请求</em></li><li><em>客户端连接成功，向服务器发送连接状态信息</em></li><li><em>服务器accept方法返回，连接成功</em></li><li><em>客户端向socket写入信息</em></li><li><em>服务器读取信息</em></li><li><em>客户端关闭</em></li><li><em>服务器端关闭</em></li></ol><h3 id="3-创建socket"><a href="#3-创建socket" class="headerlink" title="3. 创建socket"></a>3. 创建socket</h3><p>在 Python 中 使用socket 模块的函数 socket 就可以完成：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> socket</span><br><span class="line">socket.socket(AddressFamily, Type)</span><br></pre></td></tr></table></figure><h4 id="说明："><a href="#说明：" class="headerlink" title="说明："></a>说明：</h4><p>函数 socket.socket 创建一个 socket，该函数带有两个参数：</p><ul><li>Address Family：可以选择 AF_INET（用于 Internet 进程间通信） 或者 AF_UNIX（用于同一台机器进程间通信）,实际工作中常用AF_INET</li><li>Type：套接字类型，可以是 SOCK_STREAM（流式套接字，主要用于 TCP 协议）或者 SOCK_DGRAM（数据报套接字，主要用于 UDP 协议）</li></ul><p>创建一个tcp socket（tcp套接字）</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> socket</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建tcp的套接字</span></span><br><span class="line">s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)</span><br><span class="line"></span><br><span class="line"><span class="comment"># ...这里是使用套接字的功能（省略）...</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 不用的时候，关闭套接字</span></span><br><span class="line">s.close()</span><br></pre></td></tr></table></figure><p>创建一个udp socket（udp套接字）</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> socket</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建udp的套接字</span></span><br><span class="line">s = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)</span><br><span class="line"></span><br><span class="line"><span class="comment"># ...这里是使用套接字的功能（省略）...</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 不用的时候，关闭套接字</span></span><br><span class="line">s.close()</span><br></pre></td></tr></table></figure><h5 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h5><ul><li>套接字使用流程 与 文件的使用流程很类似<ol><li>创建套接字</li><li>使用套接字收/发数据</li><li>关闭套接字</li></ol></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;socket简介&quot;&gt;&lt;a href=&quot;#socket简介&quot; class=&quot;headerlink&quot; title=&quot;socket简介&quot;&gt;&lt;/a&gt;socket简介
    
    </summary>
    
      <category term="计算机网络" scheme="http://yoursite.com/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
    
      <category term="python" scheme="http://yoursite.com/tags/python/"/>
    
      <category term="计算机网络" scheme="http://yoursite.com/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
  </entry>
  
  <entry>
    <title>对python中的self的理解</title>
    <link href="http://yoursite.com/2019/03/04/python-%E5%AF%B9python%E4%B8%AD%E7%9A%84self%E7%9A%84%E7%90%86%E8%A7%A3/"/>
    <id>http://yoursite.com/2019/03/04/python-对python中的self的理解/</id>
    <published>2019-03-04T08:38:11.000Z</published>
    <updated>2019-09-21T07:19:29.722Z</updated>
    
    <content type="html"><![CDATA[<p>编写类时，每个函数参数第一个参数都是self，调用时又不需要<br><a id="more"></a></p><p><strong>self指向类的实例化对象，而非类。</strong></p><p>实例来说明</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Test</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">this</span><span class="params">(<span class="keyword">self</span>)</span></span><span class="symbol">:</span></span><br><span class="line">        print(<span class="keyword">self</span>)</span><br><span class="line">        print(<span class="keyword">self</span>.__class_<span class="number">_</span>)</span><br><span class="line"></span><br><span class="line">t = Test()</span><br><span class="line">t.this()</span><br><span class="line">Test.this(t)</span><br></pre></td></tr></table></figure><p>执行结果如下</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;__main__<span class="selector-class">.Test</span> <span class="selector-tag">object</span> at <span class="number">0</span>x000000000284E080&gt;</span><br><span class="line">&lt;class <span class="string">'__main__.Test'</span>&gt;</span><br><span class="line">&lt;class <span class="string">'__main__.Test'</span>&gt;</span><br></pre></td></tr></table></figure><p>从上面的例子中可以很明显的看出，self代表的是类的实例。而<code>self.__class__</code>​则指向类。</p><p>在Python的解释器内部，当我们调用t.prt()时，实际上Python解释成Test.this(t)，也就是说把self替换成类的实例。</p><p><strong>self不必非写成self</strong></p><p>这个参数不必非得写为self,我们可以写 abc, this等。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Test</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">prt</span><span class="params">(abc)</span>:</span></span><br><span class="line">        print(abc)</span><br><span class="line">        print(abc.__class__)</span><br><span class="line"></span><br><span class="line">t = Test()</span><br><span class="line">t.prt()</span><br></pre></td></tr></table></figure><p>改成abc后，运行结果和self是一样的。</p><p><strong>self可以不写吗</strong></p><p>self在定义时不可以省略，可以试一下，忽略的时候：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Test</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">prt</span><span class="params">()</span>:</span></span><br><span class="line">        print(self)</span><br><span class="line"></span><br><span class="line">t = Test()</span><br><span class="line">t.prt()</span><br></pre></td></tr></table></figure><p>运行时提醒错误如下：prt在定义时没有参数，但是我们运行时强行传了一个参数。<br>由于上面解释过了<code>t.prt()</code>等同于<code>Test.prt(t)</code>，所以程序提醒我们多传了一个参数t。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Traceback (most recent <span class="keyword">call</span> <span class="keyword">last</span>):</span><br><span class="line">  <span class="keyword">File</span> <span class="string">"h.py"</span>, line <span class="number">6</span>, <span class="keyword">in</span> &lt;<span class="keyword">module</span>&gt;</span><br><span class="line">    t.prt()</span><br><span class="line">TypeError: prt() takes <span class="number">0</span> positional arguments but <span class="number">1</span> was given</span><br></pre></td></tr></table></figure><p>当我们的定义和调用时均不传类实例是可以的，这就是类方法。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Test</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">prt</span><span class="params">()</span>:</span></span><br><span class="line">        print(__class__)</span><br><span class="line">Test.prt()</span><br></pre></td></tr></table></figure><p>运行结果如下</p><figure class="highlight ceylon"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;<span class="keyword">class</span> <span class="string">'__main__.Test'</span>&gt;</span><br></pre></td></tr></table></figure><p><strong>继承时，传入的是哪个实例，就那个传入的实例，而不是指定义了self的类的实例。</strong></p><p>先看代码</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Parent</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">pprt</span><span class="params">(self)</span>:</span></span><br><span class="line">        print(self)</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Child</span><span class="params">(Parent)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">cprt</span><span class="params">(self)</span>:</span></span><br><span class="line">        print(self)</span><br><span class="line">c = Child()</span><br><span class="line">c.cprt()  <span class="comment"># &lt;__main__.Child object at 0x00E289F0&gt;</span></span><br><span class="line">c.pprt()  <span class="comment"># &lt;__main__.Child object at 0x00E289F0&gt;</span></span><br><span class="line">p = Parent()</span><br><span class="line">p.pprt()  <span class="comment"># &lt;__main__.Parent object at 0x00E28B50&gt;</span></span><br></pre></td></tr></table></figure><p>从上边的代码可以看出<code>c.cprt() 和 c.pprt()</code> 运行结构一样：<br>运行<code>c.cprt()</code>时应该没有理解问题，指的是Child类的实例。<br>但是在运行<code>c.pprt()</code>时，等同于<code>Child.pprt(c)</code>，所以self指的依然是Child类的实例，由于self中没有定义<code>pprt()</code>方法，所以沿着<strong>继承树</strong>往上找，发现在父类Parent中定义了<code>pprt()</code>方法，所以就会成功调用。</p><p><strong>在描述符类中，self指的是描述符类的实例</strong></p><p>不太容易理解，先看实例：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Desc</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__get__</span><span class="params">(self, ins, cls)</span>:</span></span><br><span class="line">        print(<span class="string">'self in Desc: %s '</span> % self )</span><br><span class="line">        print(self, ins, cls)</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Test</span>:</span></span><br><span class="line">    x = Desc()</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">prt</span><span class="params">(self)</span>:</span></span><br><span class="line">        print(<span class="string">'self in Test: %s'</span> % self)</span><br><span class="line">t = Test()</span><br><span class="line">print(<span class="string">"t.prt()输出结果"</span>+<span class="string">"-"</span>*<span class="number">50</span>)</span><br><span class="line">t.prt()</span><br><span class="line">print(<span class="string">"t.x输出结果"</span>+<span class="string">"-"</span>*<span class="number">50</span>)</span><br><span class="line">t.x</span><br><span class="line">print(<span class="string">"Test.x输出结果"</span>+<span class="string">"-"</span>*<span class="number">50</span>)</span><br><span class="line">Test.x</span><br></pre></td></tr></table></figure><p>运行结果如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">t.prt()输出结果------------------------------------</span><br><span class="line">self <span class="keyword">in</span> Test: &lt;__main__.Test object at <span class="number">0x00ED8B90</span>&gt;</span><br><span class="line">t.x输出结果-----------------------------------------</span><br><span class="line">self <span class="keyword">in</span> Desc: &lt;__main__.Desc object at <span class="number">0x00ED8A90</span>&gt; </span><br><span class="line">&lt;__main__.Desc object at <span class="number">0x00ED8A90</span>&gt; &lt;__main__.Test object at <span class="number">0x00ED8B90</span>&gt; &lt;<span class="class"><span class="keyword">class</span> '<span class="title">__main__</span>.<span class="title">Test</span>'&gt;</span></span><br><span class="line"><span class="class"><span class="title">Test</span>.<span class="title">x</span>输出结果--------------------------------------</span></span><br><span class="line"><span class="class"><span class="title">self</span> <span class="title">in</span> <span class="title">Desc</span>:</span> &lt;__main__.Desc object at <span class="number">0x00ED8A90</span>&gt; </span><br><span class="line">&lt;__main__.Desc object at <span class="number">0x00ED8A90</span>&gt; <span class="keyword">None</span> &lt;<span class="class"><span class="keyword">class</span> '<span class="title">__main__</span>.<span class="title">Test</span>'&gt;</span></span><br></pre></td></tr></table></figure><p>为什么在Desc类中定义的self不是应该是调用它的实例t吗？怎么变成了Desc类的实例了呢？<br>注意：此处需要睁大眼睛看清楚了，这里调用的是t.x，也就是说是Test类的实例t的属性x，由于实例t中并没有定义属性x，所以找到了类属性x，而该属性是描述符属性，为Desc类的实例而已，所以此处并没有顶用Test的任何方法。<br>    我们们如果直接通过类来调用属性x也可以得到相同的结果。</p><p><strong>总结</strong></p><ul><li>self在定义时需要定义，但是在调用时会自动传入。</li><li>self的名字并不是规定死的，但是最好还是按照约定是用self</li><li>self总是指调用时的类的实例。</li><li>由 <strong><em>哪一个对象</em></strong> 调用的方法，方法内的self就是<strong><em>哪一个对象的引用</em></strong></li><li>在类封装的方法内部，<code>self</code> 就表示 <strong>当前调用方法的对象自己</strong></li><li>在 <strong>类的外部</strong>，通过 <code>变量名.</code> 访问对象的 <strong>属性和方法</strong></li><li>在 <strong>类封装的方法中</strong>，通过 <code>self.</code> 访问对象的 <strong>属性和方法</strong></li><li><strong>调用方法时</strong>，程序员不需要传递 <code>self</code> 参数</li><li>在方法内部<ul><li>可以通过 <code>self.</code> <strong>访问对象的属性</strong></li><li>也可以通过 <code>self.</code> <strong>调用其他的对象方法</strong></li></ul></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;编写类时，每个函数参数第一个参数都是self，调用时又不需要&lt;br&gt;
    
    </summary>
    
      <category term="python" scheme="http://yoursite.com/categories/python/"/>
    
    
      <category term="python" scheme="http://yoursite.com/tags/python/"/>
    
      <category term="函数" scheme="http://yoursite.com/tags/%E5%87%BD%E6%95%B0/"/>
    
  </entry>
  
  <entry>
    <title>批处理</title>
    <link href="http://yoursite.com/2019/01/26/%E6%89%B9%E5%A4%84%E7%90%86/"/>
    <id>http://yoursite.com/2019/01/26/批处理/</id>
    <published>2019-01-26T06:34:42.000Z</published>
    <updated>2019-03-04T08:51:22.034Z</updated>
    
    <content type="html"><![CDATA[<h2 id="批处理"><a href="#批处理" class="headerlink" title="批处理"></a>批处理</h2><a id="more"></a><h4 id="1-删除桌面图标小箭头"><a href="#1-删除桌面图标小箭头" class="headerlink" title="1.删除桌面图标小箭头"></a>1.删除桌面图标小箭头</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">reg add &quot;HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Windows\CurrentVersion\Explorer\Shell Icons&quot; /v 29 /d &quot;%systemroot%\system32\imageres.dll,197&quot; /t reg_sz /f</span><br><span class="line">taskkill /f /im explorer.exe</span><br><span class="line">attrib -s -r -h &quot;%userprofile%\AppData\Local\iconcache.db&quot;</span><br><span class="line">del &quot;%userprofile%\AppData\Local\iconcache.db&quot; /f /q</span><br><span class="line">start explorer</span><br><span class="line">pause</span><br></pre></td></tr></table></figure><h4 id="2-恢复桌面图标小箭头"><a href="#2-恢复桌面图标小箭头" class="headerlink" title="2.恢复桌面图标小箭头"></a>2.恢复桌面图标小箭头</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">reg delete &quot;HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Windows\CurrentVersion\Explorer\Shell Icons&quot; /v 29 /f</span><br><span class="line">taskkill /f /im explorer.exe</span><br><span class="line">attrib -s -r -h &quot;%userprofile%\AppData\Local\iconcache.db&quot;</span><br><span class="line">del &quot;%userprofile%\AppData\Local\iconcache.db&quot; /f /q</span><br><span class="line">start explorer</span><br><span class="line">pause</span><br></pre></td></tr></table></figure><p>####3.创建当前日期文件夹<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">@echo off</span><br><span class="line">cd/d %~dp1</span><br><span class="line">set y=%date:~0,4%</span><br><span class="line">set m=%date:~5,2%</span><br><span class="line">set d=%date:~8,2%</span><br><span class="line">mkdir &quot;%y%-%m%-%d%&quot;</span><br></pre></td></tr></table></figure></p><p>####4.一键清理垃圾文件<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">@echo off </span><br><span class="line">title 一键清除系统垃圾</span><br><span class="line">echo 正在清除系统垃圾文件，请稍等...... </span><br><span class="line">echo.</span><br><span class="line">del /f /s /q %systemdrive%\*.tmp </span><br><span class="line">del /f /s /q %systemdrive%\*._mp </span><br><span class="line">del /f /s /q %systemdrive%\*.log </span><br><span class="line">del /f /s /q %systemdrive%\*.gid </span><br><span class="line">del /f /s /q %systemdrive%\*.chk </span><br><span class="line">del /f /s /q %systemdrive%\*.old </span><br><span class="line">del /f /s /q %systemdrive%\recycled\*.* </span><br><span class="line">del /f /s /q %windir%\*.bak </span><br><span class="line">del /f /s /q %windir%\prefetch\*.* </span><br><span class="line">rd /s /q %windir%\temp &amp; md %windir%\temp </span><br><span class="line">del /f /q %userprofile%\cookies\*.* </span><br><span class="line">del /f /q %userprofile%\recent\*.* </span><br><span class="line">del /f /s /q &quot;%userprofile%\Local Settings\Temporary Internet Files\*.*&quot; </span><br><span class="line">del /f /s /q &quot;%userprofile%\Local Settings\Temp\*.*&quot; </span><br><span class="line">del /f /s /q &quot;%userprofile%\recent\*.*&quot; </span><br><span class="line">echo.</span><br><span class="line">echo 清除系统垃圾完成！ </span><br><span class="line">echo. &amp; pause</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;批处理&quot;&gt;&lt;a href=&quot;#批处理&quot; class=&quot;headerlink&quot; title=&quot;批处理&quot;&gt;&lt;/a&gt;批处理&lt;/h2&gt;
    
    </summary>
    
      <category term="Windows" scheme="http://yoursite.com/categories/Windows/"/>
    
    
      <category term="windows" scheme="http://yoursite.com/tags/windows/"/>
    
  </entry>
  
  <entry>
    <title>为什么ip地址能够通讯还需要MAC地址</title>
    <link href="http://yoursite.com/2018/12/16/%E4%B8%BA%E4%BB%80%E4%B9%88ip%E5%9C%B0%E5%9D%80%E8%83%BD%E5%A4%9F%E9%80%9A%E8%AE%AF%E8%BF%98%E9%9C%80%E8%A6%81MAC%E5%9C%B0%E5%9D%80/"/>
    <id>http://yoursite.com/2018/12/16/为什么ip地址能够通讯还需要MAC地址/</id>
    <published>2018-12-16T12:35:24.000Z</published>
    <updated>2019-01-23T07:57:17.326Z</updated>
    
    <content type="html"><![CDATA[<p>&ensp;&ensp;&ensp;&ensp;长话短说，理由有三点。<a id="more"></a><br>&ensp;&ensp;&ensp;&ensp;一. 整体与局部信息传递时候，需要知道的其实是两个地址：终点地址（Final destination address）下一跳的地址（Next hop address）IP地址本质上是终点地址，它在跳过路由器（hop）的时候不会改变，而MAC地址则是下一跳的地址，每跳过一次路由器都会改变。这就是为什么还要用MAC地址的原因之一，它起到了记录下一跳的信息的作用。注：一般来说IP地址经过路由器是不变的，不过NAT（Network address translation）例外，这也是有些人反对NAT而支持IPV6的原因之一。<br>&ensp;&ensp;&ensp;&ensp;二. 分层实现如果在IP包头（header）中增加了”下一跳IP地址“这个字段，在逻辑上来说，如果IP地址够用，交换机也支持根据IP地址转发（现在的二层交换机不支持这样做），其实MAC地址并不是必要的。但用MAC地址和IP地址两个地址，用于分别表示物理地址和逻辑地址是有好处的。这样分层可以使网络层与链路层的协议更灵活地替换，网络层不一定非要用『IP』协议，链路层也不一定非用『以太网』协议。这就像OSI七层模型，TCP/IP五层模型其实也不是必要的，用双层模型甚至单层模型实现网络也不是不可以的，只是那样做很蛋疼罢了。<br>&ensp;&ensp;&ensp;&ensp;三. 早期的『以太网』实现早期的以太网只有集线器（hub），没有交换机（switch），所以发出去的包能被以太网内的所有机器监听到，因此要附带上MAC地址，每个机器只需要接受与自己MAC地址相匹配的包。</p><p>&ensp;&ensp;&ensp;&ensp;IP地址是有限的，每一台计算机都分配一个可以直接联网的固定的IP（你每次联网可能你的IP都在变化）的话，ip地址不够用。相反，MAC地址全球固定而且唯一的，有了MAC地址就能准确的找到你的计算机。就好比手机号和身份证号，手机号可以换，而且你换了手机号，我可能就找不到你了，但是你的身份证号不会变，有了它就一定能找到你。而且，如果IP层抢了第二层的饭碗，你就不得不考虑第二层的很多东西了，这就让IP层的实现变得十分困难，这就不符合分层简化的思想。</p><p>&ensp;&ensp;&ensp;&ensp;来源链接：<a href="https://www.zhihu.com/question/21546408/answer/28155896" target="_blank" rel="noopener">https://www.zhihu.com/question/21546408/answer/28155896</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&amp;ensp;&amp;ensp;&amp;ensp;&amp;ensp;长话短说，理由有三点。
    
    </summary>
    
      <category term="十万个为什么" scheme="http://yoursite.com/categories/%E5%8D%81%E4%B8%87%E4%B8%AA%E4%B8%BA%E4%BB%80%E4%B9%88/"/>
    
    
      <category term="网络" scheme="http://yoursite.com/tags/%E7%BD%91%E7%BB%9C/"/>
    
  </entry>
  
  <entry>
    <title>为什么有了mac地址还需要IP地址</title>
    <link href="http://yoursite.com/2018/12/15/%E4%B8%BA%E4%BB%80%E4%B9%88%E6%9C%89%E4%BA%86mac%E5%9C%B0%E5%9D%80%E8%BF%98%E9%9C%80%E8%A6%81IP%E5%9C%B0%E5%9D%80/"/>
    <id>http://yoursite.com/2018/12/15/为什么有了mac地址还需要IP地址/</id>
    <published>2018-12-15T12:34:43.000Z</published>
    <updated>2019-01-23T07:56:02.145Z</updated>
    
    <content type="html"><![CDATA[<p>&ensp;&ensp;&ensp;&ensp;由于全世界存在各式各样的网络，他们使用不同的硬件地址。要是这些异构网络能够互相通信就必须进行非常复杂的硬件地址转换工作，因此由用户或用户主机来完成这项工作几乎是不可能的事。但统一的IP地址把这个复杂问题解决了。<a id="more"></a><br>&ensp;&ensp;&ensp;&ensp;连接到因特网的主机只需拥有统一的IP地址，它们之间的通信就像连接在同一个网络（虚拟互连网络或者简称IP网），因为调用ARP的复杂过程都是由计算机软件自动进行的。<br>&ensp;&ensp;&ensp;&ensp;MAC地址是物理层的地址，但它只是以太网的物理地址。互联网是由很多异构的物理网络通过路由器联接起来的，不同的物理网络，寻址方式很可能是不同的，可能根本不使用MAC地址。这样，不同的物理网络想要进行通讯就变得十分困难，因为彼此的数据帧相互不兼容。所以，我们想要一个公用的标准去遵循，这个标准就是IP。IP地址大家都知道了，属于TCP/IP协议族，它属于网络分层的第三层（网络层）。分层的好处是什么呢？就是让你不再去考虑两个不同的实现方式的物理网之间如何通讯，比如一个以太网和一个令牌环网。它屏蔽了下层的东西，让所有的网络都建立在IP地址之上，整个互联网在第三层看起来就像是一个巨大的IP网，不用去管什么以太网，令牌网，无线网等，都叫IP网，都统一使用IP来进行通讯。</p><p>&ensp;&ensp;&ensp;&ensp;mac地址就好像个人的身份证号，人的身份证号和人户口所在的城市，出生的日期有关，但是和人所在的位置没有关系，人是会移动的，知道一个人的身份证号，并不能找到它这个人，mac地址类似，它是和设备的生产者，批次，日期之类的关联起来，知道一个设备的mac，并不能在网络中将数据发送给它，除非它和发送方的在同一个网络内。</p><p>&ensp;&ensp;&ensp;&ensp;所以要实现机器之间的通信，我们还需要有ip地址的概念，ip地址表达的是当前机器在网络中的位置，类似于城市名+道路号+门牌号的概念。通过ip层的寻址，我们能知道按何种路径在全世界任意两台Internet上的的机器间传输数据。</p><p>&ensp;&ensp;&ensp;&ensp;另外mac地址通常是不变的，ip地址是可变的，尤其是移动设备，ip地址会经常变更。mac地址的设计不携带设备在网络中的位置信息，想要通过mac地址通信，我们得在所有的设备上维护一张很大的表，记录所有mac地址路由在当前位置的的下一跳，这显然不合理。<br>那么既然能够通过IP地址通讯，为什么还需要mac地址呢？</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&amp;ensp;&amp;ensp;&amp;ensp;&amp;ensp;由于全世界存在各式各样的网络，他们使用不同的硬件地址。要是这些异构网络能够互相通信就必须进行非常复杂的硬件地址转换工作，因此由用户或用户主机来完成这项工作几乎是不可能的事。但统一的IP地址把这个复杂问题解决了。
    
    </summary>
    
      <category term="十万个为什么" scheme="http://yoursite.com/categories/%E5%8D%81%E4%B8%87%E4%B8%AA%E4%B8%BA%E4%BB%80%E4%B9%88/"/>
    
    
      <category term="网络" scheme="http://yoursite.com/tags/%E7%BD%91%E7%BB%9C/"/>
    
  </entry>
  
  <entry>
    <title>为什么硬盘最多只有四个主分区</title>
    <link href="http://yoursite.com/2018/12/05/%E4%B8%BA%E4%BB%80%E4%B9%88%E7%A1%AC%E7%9B%98%E6%9C%80%E5%A4%9A%E5%8F%AA%E6%9C%89%E5%9B%9B%E4%B8%AA%E4%B8%BB%E5%88%86%E5%8C%BA/"/>
    <id>http://yoursite.com/2018/12/05/为什么硬盘最多只有四个主分区/</id>
    <published>2018-12-05T13:33:02.000Z</published>
    <updated>2019-01-23T07:56:18.328Z</updated>
    
    <content type="html"><![CDATA[<p>&ensp;&ensp;&ensp;&ensp;PC行业标准中一个硬盘只能分四个分区.这样的四个分区在不同的操作系统中被冠以不同的名称他可能叫partition （主分区）或者slice ,但是无论他们怎么叫,这些系统都支持这样的四个分区,都可以识别分区的起始位置和大小等信息。<a id="more"></a></p><p>&ensp;&ensp;&ensp;&ensp;为什么一个硬盘只能分四个主分区呢?这是由个人计算机初期的设计架构决定的。一开始,PC被设计成这样的启动过程,开机时主板BIOS进行自检,当一切OK后,就开始读取硬盘的第一个扇区,一个扇区的大小是512字节,这是计算机工业里的标准,无论什么硬盘,一个扇区的大小都是512字节。  </p><p>&ensp;&ensp;&ensp;&ensp;Boot Sector也就是硬盘的第一个扇区，它由MBR（Master Boot Record）， DPT（Disk Partition Table） 和 Boot Record ID三部分组成。MBR又称为主引导记录，占用Boot Sector的前446个字节（0~0x1BD），存放系统主引导程序（它负责从活动分区中装载并且运行系统引导程序）。 DPT即主分区表占用64个字节（0x1BE~0x1FD），记录磁盘的基本分区信息。主分区表分为四个分区项，每项16个字节，分别记录每个主分区的信息（因此最多可以有四个主分区）。 Boot Record ID即引导区标记占用两个字节（0x1FE~0x1FF），对于合法引导区，它等于0xaa55，（aa和55被称为幻数 Magic number）这是判别引导区是否合法的标志,所以,对硬盘加密的简单办法就是从MBR中察掉这两个字节.那么这个硬盘挂到任何电脑上都会显示为一个没有分区的空白硬盘.但是只要把这两个字节重新写上,数据又能读出。这样446+64+2=512字节。<br>&ensp;&ensp;&ensp;&ensp;主分区，也称为主磁盘分区，和扩展分区、逻辑分区一样，是一种分区类型。主分区中不能再划分其他类型的分区，因此每个主分区都相当于一个逻辑磁盘（在这一点上主分区和逻辑分区很相似，但主分区是直接在硬盘上划分的，逻辑分区则必须建立于扩展分区中）。   </p><p>&ensp;&ensp;&ensp;&ensp;所以可以知道：</p><pre><code>其实所谓分区只是针对那个64 bytes 的分区表进行设定而已硬盘默认的分区表仅能写入四组分区信息这四组分区信息我们称为主要(Primary)或延伸(Extend)分区槽主要分区和延伸分区最多只有四个（硬盘限制）延伸分区最多只能有一个（操作系统限制）逻辑分区是由延伸分区持续切割出来的分区槽</code></pre><p>&ensp;&ensp;&ensp;&ensp;整个启动流程到操作系统之前的动作应该是这样的：</p><pre><code>1.BIOS：启动主动运行的韧体，会认识第一个可启动的装置；2.MBR：第一个可启动装置的第一个磁区内的主要启动记录区块，内含启动管理程序；3.MBR这个仅有446 bytes的硬盘容量里面会放置最基本的启动管理程序4.启动管理程序(boot loader)：一支可读取核心文件来运行的软件；5.核心文件：开始操作系统的功能...</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&amp;ensp;&amp;ensp;&amp;ensp;&amp;ensp;PC行业标准中一个硬盘只能分四个分区.这样的四个分区在不同的操作系统中被冠以不同的名称他可能叫partition （主分区）或者slice ,但是无论他们怎么叫,这些系统都支持这样的四个分区,都可以识别分区的起始位置和大小等信息。
    
    </summary>
    
      <category term="十万个为什么" scheme="http://yoursite.com/categories/%E5%8D%81%E4%B8%87%E4%B8%AA%E4%B8%BA%E4%BB%80%E4%B9%88/"/>
    
    
      <category term="操作系统" scheme="http://yoursite.com/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
  </entry>
  
  <entry>
    <title>tcp_ip_1</title>
    <link href="http://yoursite.com/2018/11/13/tcp_ip_1/"/>
    <id>http://yoursite.com/2018/11/13/tcp_ip_1/</id>
    <published>2018-11-13T14:07:42.000Z</published>
    <updated>2019-04-18T14:29:15.525Z</updated>
    
    <content type="html"><![CDATA[<p><strong>首先，TCP/IP不是一个协议，而是一个协议族的统称。里面包括了IP协议，ICMP协议，TCP协议，以及我们更加熟悉的http、ftp、pop3协议等等。</strong><br><a id="more"></a></p><h4 id="tcp-ip协议分层"><a href="#tcp-ip协议分层" class="headerlink" title="tcp/ip协议分层"></a>tcp/ip协议分层</h4><p>TCP/IP协议族的结构和ISO-OSI的七层协议经典架构比较<br>如图所示</p><h4 id="ip地址"><a href="#ip地址" class="headerlink" title="ip地址"></a>ip地址</h4><p>&ensp;<strong>ip地址：用来在网络中标记一台电脑，比如192.168.1.1；在本地局域网上是唯一的。</strong>&ensp;&ensp;&ensp;</p><p><em>IP地址是网络号+主机号的组合</em></p><h4 id="域名系统"><a href="#域名系统" class="headerlink" title="域名系统"></a>域名系统</h4><p>&ensp;&ensp;&ensp;&ensp;域名系统是一个分布的数据库，它提供将主机名（就是网址啦）转换成IP地址的服务。</p><h4 id="RFC"><a href="#RFC" class="headerlink" title="RFC"></a>RFC</h4><p>&ensp;&ensp;&ensp;&ensp;RFC是什么？RFC就是tcp/ip协议的标准文档。</p><h4 id="端口号"><a href="#端口号" class="headerlink" title="端口号"></a>端口号</h4><p>端口是通过端口号来标记的，端口号只有整数，范围是从0到65535</p><p>注意：端口数不一样的*nix系统不一样，还可以手动修改</p><p>这个号码是用在TCP，UDP上的一个逻辑号码，并不是一个硬件端口，我们平时说把某某端口封掉了，也只是在IP层次把带有这个号码的IP包给过滤掉了而已。</p><p><strong>查看端口：</strong></p><ol><li>用“netstat －an”查看端口状态</li><li>lsof -i [tcp/udp]:2425</li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt;首先，TCP/IP不是一个协议，而是一个协议族的统称。里面包括了IP协议，ICMP协议，TCP协议，以及我们更加熟悉的http、ftp、pop3协议等等。&lt;/strong&gt;&lt;br&gt;
    
    </summary>
    
      <category term="计算机网络" scheme="http://yoursite.com/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
    
      <category term="计算机网络" scheme="http://yoursite.com/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
  </entry>
  
  <entry>
    <title>Linux常用命令</title>
    <link href="http://yoursite.com/2018/10/30/Linux%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/"/>
    <id>http://yoursite.com/2018/10/30/Linux常用命令/</id>
    <published>2018-10-30T06:19:49.000Z</published>
    <updated>2018-11-05T13:15:29.654Z</updated>
    
    <content type="html"><![CDATA[<p>自用<br><a id="more"></a></p><h4 id="man"><a href="#man" class="headerlink" title="man"></a>man</h4><p>man命令中常用按键以及用途</p><table><thead><tr><th style="text-align:center">按键</th><th style="text-align:center">用处</th></tr></thead><tbody><tr><td style="text-align:center">空格键</td><td style="text-align:center">向下翻一页</td></tr><tr><td style="text-align:center">PaGe down</td><td style="text-align:center">向下翻一页</td></tr><tr><td style="text-align:center">PaGe up</td><td style="text-align:center">向上翻一页</td></tr><tr><td style="text-align:center">home</td><td style="text-align:center">直接前往首页</td></tr><tr><td style="text-align:center">end</td><td style="text-align:center">直接前往尾页</td></tr><tr><td style="text-align:center">/</td><td style="text-align:center">从上至下搜索某个关键词，如“/linux”</td></tr><tr><td style="text-align:center">?</td><td style="text-align:center">从下至上搜索某个关键词，如“?linux”  </td></tr><tr><td style="text-align:center">n</td><td style="text-align:center">定位到下一个搜索到的关键词</td></tr><tr><td style="text-align:center">N</td><td style="text-align:center">定位到上一个搜索到的关键词</td></tr><tr><td style="text-align:center">q</td><td style="text-align:center">退出帮助文档</td></tr></tbody></table><p> man命令帮助信息的结构以及意义</p><table><thead><tr><th style="text-align:center">结构名称</th><th style="text-align:center">代表意义</th></tr></thead><tbody><tr><td style="text-align:center">NAME</td><td style="text-align:center">命令的名称</td></tr><tr><td style="text-align:center">SYNOPSIS</td><td style="text-align:center">参数的大致使用方法</td></tr><tr><td style="text-align:center">DESCRIPTION</td><td style="text-align:center">介绍说明</td></tr><tr><td style="text-align:center">EXAMPLES</td><td style="text-align:center">演示（附带简单说明）</td></tr><tr><td style="text-align:center">OVERVIEW</td><td style="text-align:center">概述</td></tr><tr><td style="text-align:center">DEFAULTS</td><td style="text-align:center">默认的功能</td></tr><tr><td style="text-align:center">OPTIONS</td><td style="text-align:center">具体的可用选项（带介绍）</td></tr><tr><td style="text-align:center">ENVIRONMENT</td><td style="text-align:center">环境变量</td></tr><tr><td style="text-align:center">FILES</td><td style="text-align:center">用到的文件</td></tr><tr><td style="text-align:center">SEE ALSO</td><td style="text-align:center">相关的资料</td></tr><tr><td style="text-align:center">HISTORY</td><td style="text-align:center">维护历史与联系方式</td></tr></tbody></table><h4 id="echo"><a href="#echo" class="headerlink" title="echo"></a>echo</h4><p>用于在终端输出字符串或变量提取后的值，格式为“echo [字符串 | $变量]”。</p><h4 id="date"><a href="#date" class="headerlink" title="date"></a>date</h4><p>用于显示及设置系统的时间或日期，格式为“date [选项] [+指定的格式]”。<br> date命令中的参数以及作用</p><table><thead><tr><th style="text-align:center">参数</th><th style="text-align:center">作用</th></tr></thead><tbody><tr><td style="text-align:center">%t</td><td style="text-align:center">跳格[Tab键]</td></tr><tr><td style="text-align:center">%H</td><td style="text-align:center">小时（00～23）</td></tr><tr><td style="text-align:center">%I</td><td style="text-align:center">小时（00～12）</td></tr><tr><td style="text-align:center">%M</td><td style="text-align:center">分钟（00～59）</td></tr><tr><td style="text-align:center">%S</td><td style="text-align:center">秒（00～59）</td></tr><tr><td style="text-align:center">%j</td><td style="text-align:center">今年中的第几天</td></tr></tbody></table><h4 id="wget"><a href="#wget" class="headerlink" title="wget"></a>wget</h4><p>用于在终端中下载网络文件，格式为“wget [参数] 下载地址”。<br>wget命令的参数以及作用</p><table><thead><tr><th style="text-align:center">参数</th><th style="text-align:center">作用</th></tr></thead><tbody><tr><td style="text-align:center">-b</td><td style="text-align:center">后台下载模式</td></tr><tr><td style="text-align:center">-P</td><td style="text-align:center">下载到指定目录</td></tr><tr><td style="text-align:center">-t</td><td style="text-align:center">最大尝试次数</td></tr><tr><td style="text-align:center">-c</td><td style="text-align:center">断点续传</td></tr><tr><td style="text-align:center">-p</td><td style="text-align:center">下载页面内所有资源，包括图片、视频等</td></tr><tr><td style="text-align:center">-r</td><td style="text-align:center">递归下载</td></tr></tbody></table><h4 id="ps"><a href="#ps" class="headerlink" title="ps"></a>ps</h4><p>ps命令用于查看系统中的进程状态，格式为“ps [参数]”。<br>ps命令的参数以及作用</p><table><thead><tr><th style="text-align:center">参数</th><th style="text-align:center">作用</th></tr></thead><tbody><tr><td style="text-align:center">-a</td><td style="text-align:center">显示所有进程（包括其他用户的进程）</td></tr><tr><td style="text-align:center">-u</td><td style="text-align:center">用户以及其他详细信息</td></tr><tr><td style="text-align:center">-x</td><td style="text-align:center">显示没有控制终端的进程</td></tr></tbody></table><p>有5种常见的进程状态，分别为运行、中断、不可中断、僵死与停止，其各自含义如下所示。</p><table><thead><tr><th style="text-align:center">进程状态</th><th style="text-align:center">含义</th></tr></thead><tbody><tr><td style="text-align:center">R（运行）</td><td style="text-align:center">进程正在运行或在运行队列中等待</td></tr><tr><td style="text-align:center">S（中断）</td><td style="text-align:center">进程处于休眠中，当某个条件形成后或者接收到信号时，则脱离该状态</td></tr><tr><td style="text-align:center">D（不可中断）</td><td style="text-align:center">进程不响应系统异步信号，即便用kill命令也不能将其中断</td></tr><tr><td style="text-align:center">Z（僵死）</td><td style="text-align:center">进程已经终止，但进程描述符依然存在, 直到父进程调用wait4()系统函数后将进程释放</td></tr><tr><td style="text-align:center">T（停止）</td><td style="text-align:center">进程收到停止信号后停止运行</td></tr></tbody></table><h4 id="top"><a href="#top" class="headerlink" title="top"></a>top</h4><p>top命令用于动态地监视进程活动与系统负载等信息，其格式为top</p><h4 id="pidof"><a href="#pidof" class="headerlink" title="pidof"></a>pidof</h4><p>pidof命令用于查询某个指定服务进程的PID值，格式为“pidof [参数] [服务名称]”。</p><h4 id="kill"><a href="#kill" class="headerlink" title="kill"></a>kill</h4><p>kill命令用于终止某个指定PID的服务进程，格式为“kill [参数] [进程PID]”。</p><h4 id="killall"><a href="#killall" class="headerlink" title="killall"></a>killall</h4><p>killall命令<br>用于终止某个指定名称的服务所对应的全部进程，格式为：“killall [参数] [服务名称]”。</p><h4 id="ifconfig"><a href="#ifconfig" class="headerlink" title="ifconfig"></a>ifconfig</h4><p>ifconfig命令用于获取网卡配置与网络状态等信息，格式为“ifconfig [网络设备] [参数]”</p><h4 id="uname"><a href="#uname" class="headerlink" title="uname"></a>uname</h4><p>uname命令用于查看系统内核与系统版本等信息，格式为“uname [-a]”。<br>看当前系统版本的详细信息，则需要查看os-release文件<br>    cat /etc/os-release</p><h4 id="uptime"><a href="#uptime" class="headerlink" title="uptime"></a>uptime</h4><p>uptime用于查看系统的负载信息，它可以显示当前系统时间、系统已运行时间、启用终端数量以及平均负载值等信息。平均负载值指的是系统在最近1分钟、5分钟、15分钟内的压力情况（下面加粗的信息部分）；负载值越低越好，尽量不要长期超过1，在生产环境中不要超过5。</p><h4 id="free"><a href="#free" class="headerlink" title="free"></a>free</h4><p>free用于显示当前系统中内存的使用量信息，格式为“free [-h]”。</p><h4 id="last"><a href="#last" class="headerlink" title="last"></a>last</h4><p>last命令用于查看所有系统的登录记录，格式为“last [参数]”。</p><h4 id="sosreport"><a href="#sosreport" class="headerlink" title="sosreport"></a>sosreport</h4><p>sosreport命令用于收集系统配置及架构信息并输出诊断文档，格式为sosreport。<br>当Linux系统出现故障需要联系技术支持人员时，大多数时候都要先使用这个命令来简单收集系统的运行状态和服务配置信息，以便让技术支持人员能够远程解决一些小问题，亦或让他们能提前了解某些复杂问题。</p><h4 id="cat"><a href="#cat" class="headerlink" title="cat"></a>cat</h4><p>cat命令用于查看纯文本文件（内容较少的），格式为“cat [选项] [文件]”。</p><h4 id="more"><a href="#more" class="headerlink" title="more"></a>more</h4><p>more命令用于查看纯文本文件（内容较多的），格式为“more [选项]文件”。</p><h4 id="head"><a href="#head" class="headerlink" title="head"></a>head</h4><p>head命令用于查看纯文本文档的前N行，格式为“head [选项] [文件]”。</p><h4 id="tail"><a href="#tail" class="headerlink" title="tail"></a>tail</h4><p>tail命令用于查看纯文本文档的后N行或持续刷新内容，格式为“tail [选项] [文件]”。<br>需要查看文本内容的最后20行，这时就需要用到tail命令了。tail命令的操作方法与head命令非常相似，只需要执行“tail -n 20 文件名”命令就可以达到这样的效果。tail命令最强悍的功能是可以持续刷新一个文件的内容，当想要实时查看最新日志文件时，这特别有用，此时的命令格式为“tail -f 文件名”：</p><h4 id="tr"><a href="#tr" class="headerlink" title="tr"></a>tr</h4><p>tr命令用于替换文本文件中的字符，格式为“tr [原始字符] [目标字符]”。</p><h4 id="wc"><a href="#wc" class="headerlink" title="wc"></a>wc</h4><p>wc命令用于统计指定文本的行数、字数、字节数，格式为“wc [参数] 文本”。<br> wc的参数以及作用</p><table><thead><tr><th style="text-align:center">参数</th><th style="text-align:center">作用</th></tr></thead><tbody><tr><td style="text-align:center">-l</td><td style="text-align:center">只显示行数</td></tr><tr><td style="text-align:center">-w</td><td style="text-align:center">只显示单词数</td></tr><tr><td style="text-align:center">-c</td><td style="text-align:center">只显示字节数</td></tr></tbody></table><h4 id="stat"><a href="#stat" class="headerlink" title="stat"></a>stat</h4><p>stat命令用于查看文件的具体存储信息和时间等信息，格式为“stat 文件名称”。</p><h4 id="cut"><a href="#cut" class="headerlink" title="cut"></a>cut</h4><p>cut命令用于按“列”提取文本字符，格式为“cut [参数] 文本”。</p><h4 id="diff"><a href="#diff" class="headerlink" title="diff"></a>diff</h4><p>diff命令用于比较多个文本文件的差异，格式为“diff [参数] 文件”。<br>在使用diff命令时，不仅可以使用–brief参数来确认两个文件是否不同，还可以使用-c参数来详细比较出多个文件的差异之处，这绝对是判断文件是否被篡改的有力神器。例如，先使用cat命令分别查看diff_A.txt和diff_B.txt文件的内容，然后进行比较</p><h4 id="touch"><a href="#touch" class="headerlink" title="touch"></a>touch</h4><p>touch命令用于创建空白文件或设置文件的时间，格式为“touch [选项] [文件]”。<br>对touch命令来讲，有难度的操作主要是体现在设置文件内容的修改时间（mtime）、文件权限或属性的更改时间（ctime）与文件的读取时间（atime）上面。touch命令的参数及其作用如表所示。</p><p> touch命令的参数及其作用</p><table><thead><tr><th style="text-align:center">参数</th><th style="text-align:center">作用</th></tr></thead><tbody><tr><td style="text-align:center">-a</td><td style="text-align:center">仅修改“读取时间”（atime）</td></tr><tr><td style="text-align:center">-m</td><td style="text-align:center">仅修改“修改时间”（mtime）</td></tr><tr><td style="text-align:center">-d</td><td style="text-align:center">同时修改atime与mtime</td></tr></tbody></table><h4 id="mkdir"><a href="#mkdir" class="headerlink" title="mkdir"></a>mkdir</h4><p>mkdir命令用于创建空白的目录，格式为“mkdir [选项] 目录”。</p><h4 id="cp"><a href="#cp" class="headerlink" title="cp"></a>cp</h4><p>cp命令用于复制文件或目录，格式为“cp [选项] 源文件 目标文件”。大家对文件复制操作应该不陌生，在Linux系统中，复制操作具体分为3种情况：</p><pre><code>如果目标文件是目录，则会把源文件复制到该目录中；如果目标文件也是普通文件，则会询问是否要覆盖它；如果目标文件不存在，则执行正常的复制操作。</code></pre><p>cp命令的参数及其作用</p><table><thead><tr><th style="text-align:center">参数</th><th style="text-align:center">作用</th></tr></thead><tbody><tr><td style="text-align:center">-p</td><td style="text-align:center">保留原始文件的属性</td></tr><tr><td style="text-align:center">-d</td><td style="text-align:center">若对象为“链接文件”，则保留该“链接文件”的属性</td></tr><tr><td style="text-align:center">-r</td><td style="text-align:center">递归持续复制（用于目录）</td></tr><tr><td style="text-align:center">-i</td><td style="text-align:center">若目标文件存在则询问是否覆盖</td></tr><tr><td style="text-align:center">-a</td><td style="text-align:center">相当于-pdr（p、d、r为上述参数）</td></tr></tbody></table><h4 id="mv"><a href="#mv" class="headerlink" title="mv"></a>mv</h4><p>mv命令用于剪切文件或将文件重命名，格式为“mv [选项] 源文件 [目标路径|目标文件名]”。</p><h4 id="rm"><a href="#rm" class="headerlink" title="rm"></a>rm</h4><p>rm命令用于删除文件或目录，格式为“rm [选项] 文件”。</p><h4 id="dd"><a href="#dd" class="headerlink" title="dd"></a>dd</h4><p>dd命令用于按照指定大小和个数的数据块来复制文件或转换文件，格式为“dd [参数]”。<br>  dd命令的参数及其作用</p><table><thead><tr><th style="text-align:center">参数</th><th style="text-align:center">作用</th></tr></thead><tbody><tr><td style="text-align:center">if</td><td style="text-align:center">输入的文件名称</td></tr><tr><td style="text-align:center">of</td><td style="text-align:center">输出的文件名称</td></tr><tr><td style="text-align:center">bs</td><td style="text-align:center">设置每个“块”的大小</td></tr><tr><td style="text-align:center">count</td><td style="text-align:center">设置要复制“块”的个数</td></tr></tbody></table><h4 id="file"><a href="#file" class="headerlink" title="file"></a>file</h4><p>file命令用于查看文件的类型，格式为“file 文件名”。<br>在Linux系统中，由于文本、目录、设备等所有这些一切都统称为文件，而我们又不能单凭后缀就知道具体的文件类型，这时就需要使用file命令来查看文件类型了。</p><h4 id="tar"><a href="#tar" class="headerlink" title="tar"></a>tar</h4><p>tar命令用于对文件进行打包压缩或解压，格式为“tar [选项] [文件]”。<br> tar命令的参数及其作用</p><table><thead><tr><th style="text-align:center">参数</th><th style="text-align:center">作用</th></tr></thead><tbody><tr><td style="text-align:center">-c</td><td style="text-align:center">创建压缩文件</td></tr><tr><td style="text-align:center">-x</td><td style="text-align:center">解开压缩文件</td></tr><tr><td style="text-align:center">-t</td><td style="text-align:center">查看压缩包内有哪些文件</td></tr><tr><td style="text-align:center">-z</td><td style="text-align:center">用Gzip压缩或解压</td></tr><tr><td style="text-align:center">-j</td><td style="text-align:center">用bzip2压缩或解压</td></tr><tr><td style="text-align:center">-v</td><td style="text-align:center">显示压缩或解压的过程</td></tr><tr><td style="text-align:center">-f</td><td style="text-align:center">目标文件名</td></tr><tr><td style="text-align:center">-p</td><td style="text-align:center">保留原始的权限与属性</td></tr><tr><td style="text-align:center">-P</td><td style="text-align:center">使用绝对路径来压缩</td></tr><tr><td style="text-align:center">-C</td><td style="text-align:center">指定解压到的目录</td></tr></tbody></table><h4 id="grep"><a href="#grep" class="headerlink" title="grep"></a>grep</h4><p>grep命令用于在文本中执行关键词搜索，并显示匹配的结果，格式为“grep [选项] [文件]”。<br>   grep命令的参数及其作用</p><table><thead><tr><th style="text-align:center">参数</th><th style="text-align:center">作用</th></tr></thead><tbody><tr><td style="text-align:center">-b</td><td style="text-align:center">将可执行文件(binary)当作文本文件（text）来搜索</td></tr><tr><td style="text-align:center">-c</td><td style="text-align:center">仅显示找到的行数</td></tr><tr><td style="text-align:center">-i</td><td style="text-align:center">忽略大小写</td></tr><tr><td style="text-align:center">-n</td><td style="text-align:center">显示行号</td></tr><tr><td style="text-align:center">-v</td><td style="text-align:center">反向选择——仅列出没有“关键词”的行。</td></tr></tbody></table><h4 id="find"><a href="#find" class="headerlink" title="find"></a>find</h4><p>find命令用于按照指定条件来查找文件，格式为“find [查找路径] 寻找条件 操作”。<br>在Linux系统中，搜索工作一般都是通过find命令来完成的，它可以使用不同的文件特性作为寻找条件（如文件名、大小、修改时间、权限等信息），一旦匹配成功则默认将信息显示到屏幕上。<br>  find命令中的参数以及作用</p><table><thead><tr><th style="text-align:center">参数</th><th style="text-align:center">作用</th></tr></thead><tbody><tr><td style="text-align:center">-name</td><td style="text-align:center">匹配名称</td></tr><tr><td style="text-align:center">-perm</td><td style="text-align:center">匹配权限（mode为完全匹配，-mode为包含即可）</td></tr><tr><td style="text-align:center">-user</td><td style="text-align:center">匹配所有者</td></tr><tr><td style="text-align:center">-group</td><td style="text-align:center">匹配所有组</td></tr><tr><td style="text-align:center">-mtime -n +n</td><td style="text-align:center">匹配修改内容的时间（-n指n天以内，+n指n天以前）</td></tr><tr><td style="text-align:center">-atime -n +n</td><td style="text-align:center">匹配访问文件的时间（-n指n天以内，+n指n天以前）</td></tr><tr><td style="text-align:center">-ctime -n +n</td><td style="text-align:center">匹配修改文件权限的时间（-n指n天以内，+n指n天以前）</td></tr><tr><td style="text-align:center">-nouser</td><td style="text-align:center">匹配无所有者的文件</td></tr><tr><td style="text-align:center">-nogroup</td><td style="text-align:center">匹配无所有组的文件</td></tr><tr><td style="text-align:center">-newer f1 !f2</td><td style="text-align:center">匹配比文件f1新但比f2旧的文件</td></tr><tr><td style="text-align:center">–type b/d/c/p/l/f</td><td style="text-align:center">匹配文件类型（后面的字幕字母依次表示块设备、目录、字符设备、管道、链接文件、文本文件）</td></tr><tr><td style="text-align:center">-size</td><td style="text-align:center">匹配文件的大小（+50KB为查找超过50KB的文件，而-50KB为查找小于50KB的文件）</td></tr><tr><td style="text-align:center">-prune</td><td style="text-align:center">忽略某个目录</td></tr><tr><td style="text-align:center">-exec …… {}\;</td><td style="text-align:center">后面可跟用于进一步处理搜索结果的命令（下文会有演示）</td></tr></tbody></table>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;自用&lt;br&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Centos7.4.1708 单机部署 Oracle11g R2 11.2.0.4 环境</title>
    <link href="http://yoursite.com/2018/10/15/centos%20%E5%AE%89%E8%A3%85%20oracle%2011g/"/>
    <id>http://yoursite.com/2018/10/15/centos 安装 oracle 11g/</id>
    <published>2018-10-15T04:00:00.000Z</published>
    <updated>2019-04-18T14:18:04.153Z</updated>
    
    <content type="html"><![CDATA[<p>操作系统 ：centos 7.4.1708 64位<br>数据库 ： oracle 11g 11.2.0.4 r2 版本<br><a id="more"></a><br>修改操作系统的核心参数<br>    在Root用户下执行以下步骤：</p><h4 id="修改用户的SHELL的限制"><a href="#修改用户的SHELL的限制" class="headerlink" title="修改用户的SHELL的限制"></a>修改用户的SHELL的限制</h4><ul><li>vi /etc/security/limits.conf  </li></ul><p>修改文件将下列内容加入该文件。</p><pre><code>oracle soft nproc 2047oracle hard nproc 16384oracle soft nofile 1024oracle hard nofile 65536</code></pre><h4 id="修改login文件"><a href="#修改login文件" class="headerlink" title="修改login文件"></a>修改login文件</h4><ul><li>vi /etc/pam.d/login</li></ul><pre><code>session required /lib/security/pam_limits.sosession required pam_limits.so</code></pre><h4 id="修改linux内核"><a href="#修改linux内核" class="headerlink" title="修改linux内核"></a>修改linux内核</h4><ul><li>vi /etc/sysctl.conf</li></ul><pre><code>fs.file-max = 6815744fs.aio-max-nr = 1048576kernel.shmall = 2097152kernel.shmmax = 2147483648kernel.shmmni = 4096kernel.sem = 250 32000 100 128net.ipv4.ip_local_port_range = 9000 65500net.core.rmem_default = 4194304net.core.rmem_max = 4194304net.core.wmem_default = 262144net.core.wmem_max = 1048576</code></pre><h4 id="使-etc-sysctl-conf-更改立即生效"><a href="#使-etc-sysctl-conf-更改立即生效" class="headerlink" title="使 /etc/sysctl.conf 更改立即生效"></a>使 /etc/sysctl.conf 更改立即生效</h4><ul><li>sysctl -p</li></ul><pre><code>net.ipv4.icmp_echo_ignore_broadcasts = 1net.ipv4.conf.all.rp_filter = 1fs.file-max = 6815744fs.aio-max-nr = 1048576kernel.shmall = 2097152kernel.shmmax = 2147483648kernel.shmmni = 4096kernel.sem = 250 32000 100 128net.ipv4.ip_local_port_range = 9000 65500net.core.rmem_default = 4194304net.core.rmem_max = 4194304net.core.wmem_default = 262144net.core.wmem_max = 1048576</code></pre><h4 id="编辑-etc-profile"><a href="#编辑-etc-profile" class="headerlink" title="编辑 /etc/profile"></a>编辑 /etc/profile</h4><ul><li>vi /etc/profile</li></ul><pre><code>if [ $USER = "oracle" ]; thenif [ $SHELL = "/bin/ksh" ]; thenulimit -p 16384ulimit -n 65536elseulimit -u 16384 -n 65536fifi</code></pre><h4 id="创建相关用户和组"><a href="#创建相关用户和组" class="headerlink" title="创建相关用户和组"></a>创建相关用户和组</h4><p>作为软件安装和支持组的拥有者。创建Oracle用户和密码,输入命令：</p><pre><code>groupadd oinstallgroupadd dbauseradd -g oinstall -G dba -m oraclepasswd oracle</code></pre><h4 id="创建数据库软件目录和数据文件存放目录"><a href="#创建数据库软件目录和数据文件存放目录" class="headerlink" title="创建数据库软件目录和数据文件存放目录"></a>创建数据库软件目录和数据文件存放目录</h4><p>目录的位置，根据自己的情况来定，注意磁盘空间即可，这里我把其放到oracle用户下</p><pre><code>mkdir -p /home/oracle/appmkdir -p /home/oracle/app/oraclemkdir -p /home/oracle/app/oradatamkdir -p /home/oracle/app/oracle/product</code></pre><h4 id="更改目录属主为Oracle用户所有"><a href="#更改目录属主为Oracle用户所有" class="headerlink" title="更改目录属主为Oracle用户所有"></a>更改目录属主为Oracle用户所有</h4><p>输入命令：</p><pre><code>chown -R oracle:oinstall /home/oracle/app</code></pre><h4 id="配置oracle用户的环境变量"><a href="#配置oracle用户的环境变量" class="headerlink" title="配置oracle用户的环境变量"></a>配置oracle用户的环境变量</h4><p>使用  <strong>su – oracle</strong>  切换到新创建的oracle用户下  </p><ul><li>vi .bash_profile</li></ul><pre><code>export ORACLE_BASE=/home/oracle/appexport ORACLE_HOME=$ORACLE_BASE/oracle/product/11.2.0/dbhome_1export ORACLE_SID=orcl,hhdbexport PATH=$PATH:$HOME/bin:$ORACLE_HOME/binexport LD_LIBRARY_PATH=$ORACLE_HOME/lib:/usr/lib</code></pre><h4 id="修改-etc-hosts文件"><a href="#修改-etc-hosts文件" class="headerlink" title="修改/etc/hosts文件"></a>修改/etc/hosts文件</h4><ul><li>vi /etc/hosts</li></ul><p>增加本机IP地址和主机名对应关系</p><h4 id="乱码的处理"><a href="#乱码的处理" class="headerlink" title="乱码的处理"></a>乱码的处理</h4><p>一般只有安装的操作系统界面是中文的时候，安装oracle11g英文，会出现乱码   </p><ul><li>export  LANG=en_US  </li></ul><h4 id="关闭防火墙和selinux"><a href="#关闭防火墙和selinux" class="headerlink" title="关闭防火墙和selinux"></a>关闭防火墙和selinux</h4><pre><code>systemctl disable firewalldsystemctl stop firewalldsystemctl disable iptablessystemctl disable ip6tablessystemctl stop ip6tablessystemctl stop ipv6tables</code></pre><ul><li><p>vi /etc/selinux/config<br>vi config</p><p>   This file controls the state of SELinux on the system.<br>   SELINUX= can take one of these three values:</p><pre><code>enforcing - SELinux security policy is enforced.permissive - SELinux prints warnings instead of enforcing.disabled - No SELinux policy is loaded.</code></pre><p>  SELINUX=disabled<br>   SELINUXTYPE= can take one of three two values:</p><pre><code>targeted - Targeted processes are protected,minimum - Modification of targeted policy. Only selected processes are protected. mls - Multi Level Security protection.</code></pre><p>  SELINUXTYPE=targeted<br>保存退出，重启操作系统。</p><h4 id="修改OS系统标识"><a href="#修改OS系统标识" class="headerlink" title="修改OS系统标识"></a>修改OS系统标识</h4><p>Oracle数据库支持在红帽和Oracle Linux上安装，不支持在CentOS上安装，所以需要修改OS系统标识为红帽。  </p></li><li><p>vi /etc/redhat-release<br>修改系统标识为redhat-7  </p><h4 id="安装补丁包"><a href="#安装补丁包" class="headerlink" title="安装补丁包"></a>安装补丁包</h4><pre><code>yum install libgccyum install -y gcc libaio glibc.i686 compat-libstdc++-33 compat-libstdc++-33.i686 elfutils-libelf-devel glibc-devel glibc-headers gcc-c++ libaio-devel libaio-devel.i686 libgcc.i686 libstdc++ libstdc++.i686 unixODBC unixODBC.i686 unixODBC-devel unixODBC-devel.i686 ksh</code></pre>安装后，yum remove ksh，卸载掉，安装下载的pdksh补丁包。一共19个安装包，pdksh可能需要单独安装。安装oracle11g软件解压oracle11g软件包<pre><code>unzip linux.x64_11gR2_database_1of2.zipunzip linux.x64_11gR2_database_2of2.zip</code></pre><p>  chown -R oracle. database/<br>以orcle用户登录图形界面安装oracle<br>进入database目录，执行runInstalle<br><code>./runInstaller</code><br>在安装完成后，先执行下面两个脚本再点击确定<br>  /u01/app/oraInventory/orainstRoot.sh<br>…………………<br>  /u01/app/oracle/db/root.sh<br>Running Oracle 11g root.sh script…<br>………………..<br>创建数据库，oracle用户下使用dbca工具创建.</p></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;操作系统 ：centos 7.4.1708 64位&lt;br&gt;数据库 ： oracle 11g 11.2.0.4 r2 版本&lt;br&gt;
    
    </summary>
    
      <category term="linux" scheme="http://yoursite.com/categories/linux/"/>
    
    
      <category term="操作系统" scheme="http://yoursite.com/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
      <category term="数据库" scheme="http://yoursite.com/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
  </entry>
  
  <entry>
    <title>岳阳楼记</title>
    <link href="http://yoursite.com/2018/10/12/wo/"/>
    <id>http://yoursite.com/2018/10/12/wo/</id>
    <published>2018-10-12T09:21:06.000Z</published>
    <updated>2018-10-15T05:37:03.776Z</updated>
    
    <content type="html"><![CDATA[<p>庆历四年春，滕子京谪守巴陵郡。越明年，政通人和，百废具兴。乃重修岳阳楼，增其旧制，刻唐贤今人诗赋于其上。属予作文以记之。</p><p><a id="more"></a>予观夫巴陵胜状，在洞庭一湖。衔远山，吞长江，浩浩汤汤，横无际涯；朝晖夕阴，气象万千。此则岳阳楼之大观也，前人之述备矣。然则北通巫峡，南极潇湘，迁客骚人，多会于此，览物之情，得无异乎？</p><p>若夫霪雨霏霏，连月不开，阴风怒号，浊浪排空；日星隐曜，山岳潜形；商旅不行，樯倾楫摧；薄暮冥冥，虎啸猿啼。登斯楼也，则有去国怀乡，忧谗畏讥，满目萧然，感极而悲者矣。</p><p>至若春和景明，波澜不惊，上下天光，一碧万顷；沙鸥翔集，锦鳞游泳；岸芷汀兰，郁郁青青。而或长烟一空，皓月千里，浮光跃金，静影沉璧，渔歌互答，此乐何极！登斯楼也，则有心旷神怡，宠辱偕忘，把酒临风，其喜洋洋者矣。</p><p>嗟夫！予尝求古仁人之心，或异二者之为，何哉？不以物喜，不以己悲；居庙堂之高则忧其民；处江湖之远则忧其君。是进亦忧，退亦忧。然则何时而乐耶？其必曰“先天下之忧而忧，后天下之乐而乐”乎。噫！微斯人，吾谁与归？</p><p>时六年九月十五日。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;庆历四年春，滕子京谪守巴陵郡。越明年，政通人和，百废具兴。乃重修岳阳楼，增其旧制，刻唐贤今人诗赋于其上。属予作文以记之。&lt;/p&gt;
&lt;p&gt;
    
    </summary>
    
    
  </entry>
  
</feed>
